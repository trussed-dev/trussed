<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate contains generic implementation of block cipher modes of operation."><meta name="keywords" content="rust, rustlang, rust-lang, block_modes"><title>block_modes - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../block_modes/index.html'><div class='logo-container'><img src='https://raw.githubusercontent.com/RustCrypto/meta/master/logo.svg' alt='logo'></div></a><p class="location">Crate block_modes</p><div class="block version"><p>Version 0.8.1</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all block_modes's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class="location"></p><div id="sidebar-vars" data-name="block_modes" data-ty="mod" data-relpath="../"></div></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="">block_modes</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/block_modes/lib.rs.html#1-111" title="goto source code">[src]</a></span></h1><div class="docblock"><p>This crate contains generic implementation of <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">block cipher modes of
operation</a>.</p>
<p>Note that some block modes (such as CTR, CFB, and OFB) transform block ciphers
into stream ciphers. Implementations in this crate require padding, so if you
want use those modes as stream ciphers (i.e. without padding), then check out
crates in the <a href="https://github.com/RustCrypto/stream-ciphers">RustCrypto/stream-ciphers</a> repository.</p>
<h1 id="usage-example" class="section-header"><a href="#usage-example">Usage example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">aes</span>::<span class="ident">Aes128</span>;
<span class="kw">use</span> <span class="ident">block_modes</span>::{<span class="ident">BlockMode</span>, <span class="ident">Cbc</span>};
<span class="kw">use</span> <span class="ident">block_modes</span>::<span class="ident">block_padding</span>::<span class="ident">Pkcs7</span>;
<span class="kw">use</span> <span class="ident">hex_literal</span>::<span class="ident">hex</span>;

<span class="comment">// create an alias for convenience</span>
<span class="kw">type</span> <span class="ident">Aes128Cbc</span> <span class="op">=</span> <span class="ident">Cbc</span><span class="op">&lt;</span><span class="ident">Aes128</span>, <span class="ident">Pkcs7</span><span class="op">&gt;</span>;

<span class="kw">let</span> <span class="ident">key</span> <span class="op">=</span> <span class="macro">hex</span><span class="macro">!</span>(<span class="string">&quot;000102030405060708090a0b0c0d0e0f&quot;</span>);
<span class="kw">let</span> <span class="ident">iv</span> <span class="op">=</span> <span class="macro">hex</span><span class="macro">!</span>(<span class="string">&quot;f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff&quot;</span>);
<span class="kw">let</span> <span class="ident">plaintext</span> <span class="op">=</span> <span class="string">b&quot;Hello world!&quot;</span>;
<span class="kw">let</span> <span class="ident">cipher</span> <span class="op">=</span> <span class="ident">Aes128Cbc</span>::<span class="ident">new_from_slices</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>, <span class="kw-2">&amp;</span><span class="ident">iv</span>).<span class="ident">unwrap</span>();

<span class="comment">// buffer must have enough space for message+padding</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
<span class="comment">// copy message to the buffer</span>
<span class="kw">let</span> <span class="ident">pos</span> <span class="op">=</span> <span class="ident">plaintext</span>.<span class="ident">len</span>();
<span class="ident">buffer</span>[..<span class="ident">pos</span>].<span class="ident">copy_from_slice</span>(<span class="ident">plaintext</span>);
<span class="kw">let</span> <span class="ident">ciphertext</span> <span class="op">=</span> <span class="ident">cipher</span>.<span class="ident">encrypt</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buffer</span>, <span class="ident">pos</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ciphertext</span>, <span class="macro">hex</span><span class="macro">!</span>(<span class="string">&quot;1b7a4c403124ae2fb52bedc534d82fa8&quot;</span>));

<span class="comment">// re-create cipher mode instance</span>
<span class="kw">let</span> <span class="ident">cipher</span> <span class="op">=</span> <span class="ident">Aes128Cbc</span>::<span class="ident">new_from_slices</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>, <span class="kw-2">&amp;</span><span class="ident">iv</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">ciphertext</span>.<span class="ident">to_vec</span>();
<span class="kw">let</span> <span class="ident">decrypted_ciphertext</span> <span class="op">=</span> <span class="ident">cipher</span>.<span class="ident">decrypt</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decrypted_ciphertext</span>, <span class="ident">plaintext</span>);</pre></div>
<p>With an enabled <code>alloc</code> feature (which is enabled by default) you can use
<code>encrypt_vec</code> and <code>descrypt_vec</code> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">cipher</span> <span class="op">=</span> <span class="ident">Aes128Cbc</span>::<span class="ident">new_from_slices</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>, <span class="kw-2">&amp;</span><span class="ident">iv</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">ciphertext</span> <span class="op">=</span> <span class="ident">cipher</span>.<span class="ident">encrypt_vec</span>(<span class="ident">plaintext</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">ciphertext</span>, <span class="macro">hex</span><span class="macro">!</span>(<span class="string">&quot;1b7a4c403124ae2fb52bedc534d82fa8&quot;</span>));

<span class="kw">let</span> <span class="ident">cipher</span> <span class="op">=</span> <span class="ident">Aes128Cbc</span>::<span class="ident">new_from_slices</span>(<span class="kw-2">&amp;</span><span class="ident">key</span>, <span class="kw-2">&amp;</span><span class="ident">iv</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">decrypted_ciphertext</span> <span class="op">=</span> <span class="ident">cipher</span>.<span class="ident">decrypt_vec</span>(<span class="kw-2">&amp;</span><span class="ident">ciphertext</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">decrypted_ciphertext</span>, <span class="ident">plaintext</span>);</pre></div>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use <a class="mod" href="../block_padding/index.html" title="mod block_padding">block_padding</a>;</code></td></tr><tr><td><code>pub use <a class="mod" href="../cipher/index.html" title="mod cipher">cipher</a>;</code></td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.BlockModeError.html" title="block_modes::BlockModeError struct">BlockModeError</a></td><td class="docblock-short"><p>Block mode error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Cbc.html" title="block_modes::Cbc struct">Cbc</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC">Cipher Block Chaining</a> (CBC) block cipher mode instance.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Cfb.html" title="block_modes::Cfb struct">Cfb</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)">Cipher feedback</a> (CFB) block mode instance with a full block feedback.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Cfb8.html" title="block_modes::Cfb8 struct">Cfb8</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)">Cipher feedback</a> (CFB) block mode instance with a full block feedback.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Ecb.html" title="block_modes::Ecb struct">Ecb</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Electronic Codebook</a> (ECB) block cipher mode instance.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Ige.html" title="block_modes::Ige struct">Ige</a></td><td class="docblock-short"><p><a href="https://www.links.org/files/openssl-ige.pdf">Infinite Garble Extension</a> (IGE) block cipher mode instance.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.InvalidKeyIvLength.html" title="block_modes::InvalidKeyIvLength struct">InvalidKeyIvLength</a></td><td class="docblock-short"><p>Invalid key or IV length error.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Ofb.html" title="block_modes::Ofb struct">Ofb</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_feedback_(CFB)">Output feedback</a> (OFB) block mode instance with a full block feedback.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Pcbc.html" title="block_modes::Pcbc struct">Pcbc</a></td><td class="docblock-short"><p><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#PCBC">Propagating Cipher Block Chaining</a> (PCBC) mode instance.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.BlockMode.html" title="block_modes::BlockMode trait">BlockMode</a></td><td class="docblock-short"><p>Trait for a block cipher mode of operation that is used to apply a block cipher
operation to input data to transform it into a variable-length output message.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.IvState.html" title="block_modes::IvState trait">IvState</a></td><td class="docblock-short"><p>Trait for a BlockMode, used to obtain the current state in the form of an IV
that can initialize a BlockMode later and resume the original operation.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="block_modes" data-search-js="../search-index.js"></div>
    <script src="../main.js"></script></body></html>