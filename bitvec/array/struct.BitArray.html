<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `BitArray` struct in crate `bitvec`."><meta name="keywords" content="rust, rustlang, rust-lang, BitArray"><title>bitvec::array::BitArray - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct BitArray</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.as_bitslice">as_bitslice</a><a href="#method.as_buffer">as_buffer</a><a href="#method.as_mut_bitslice">as_mut_bitslice</a><a href="#method.as_mut_buffer">as_mut_buffer</a><a href="#method.as_mut_raw_slice">as_mut_raw_slice</a><a href="#method.as_raw_slice">as_raw_slice</a><a href="#method.new">new</a><a href="#method.value">value</a><a href="#method.zeroed">zeroed</a></div><a class="sidebar-title" href="#deref-methods-BitSlice%3CO%2C%20V%3A%3AStore%3E">Methods from Deref&lt;Target=BitSlice&lt;O, V::Store&gt;&gt;</a><div class="sidebar-links"><a href="#method.align_to">align_to</a><a href="#method.align_to_mut">align_to_mut</a><a href="#method.all">all</a><a href="#method.any">any</a><a href="#method.as_bitptr">as_bitptr</a><a href="#method.as_bitptr_range">as_bitptr_range</a><a href="#method.as_mut_bitptr">as_mut_bitptr</a><a href="#method.as_mut_bitptr_range">as_mut_bitptr_range</a><a href="#method.as_slice">as_slice</a><a href="#method.bit_domain">bit_domain</a><a href="#method.bit_domain_mut">bit_domain_mut</a><a href="#method.chunks">chunks</a><a href="#method.chunks_exact">chunks_exact</a><a href="#method.chunks_exact_mut">chunks_exact_mut</a><a href="#method.chunks_mut">chunks_mut</a><a href="#method.clone_from_bitslice">clone_from_bitslice</a><a href="#method.contains">contains</a><a href="#method.copy_from_bitslice">copy_from_bitslice</a><a href="#method.copy_within">copy_within</a><a href="#method.copy_within_unchecked">copy_within_unchecked</a><a href="#method.count_ones">count_ones</a><a href="#method.count_zeros">count_zeros</a><a href="#method.domain">domain</a><a href="#method.domain_mut">domain_mut</a><a href="#method.ends_with">ends_with</a><a href="#method.first">first</a><a href="#method.first_mut">first_mut</a><a href="#method.first_one">first_one</a><a href="#method.first_zero">first_zero</a><a href="#method.for_each">for_each</a><a href="#method.get">get</a><a href="#method.get_mut">get_mut</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.is_empty">is_empty</a><a href="#method.iter">iter</a><a href="#method.iter_mut">iter_mut</a><a href="#method.iter_ones">iter_ones</a><a href="#method.iter_zeros">iter_zeros</a><a href="#method.last">last</a><a href="#method.last_mut">last_mut</a><a href="#method.last_one">last_one</a><a href="#method.last_zero">last_zero</a><a href="#method.leading_ones">leading_ones</a><a href="#method.leading_zeros">leading_zeros</a><a href="#method.len">len</a><a href="#method.not_all">not_all</a><a href="#method.not_any">not_any</a><a href="#method.offset_from">offset_from</a><a href="#method.rchunks">rchunks</a><a href="#method.rchunks_exact">rchunks_exact</a><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a><a href="#method.rchunks_mut">rchunks_mut</a><a href="#method.reverse">reverse</a><a href="#method.rotate_left">rotate_left</a><a href="#method.rotate_right">rotate_right</a><a href="#method.rsplit">rsplit</a><a href="#method.rsplit_mut">rsplit_mut</a><a href="#method.rsplitn">rsplitn</a><a href="#method.rsplitn_mut">rsplitn_mut</a><a href="#method.set">set</a><a href="#method.set_aliased">set_aliased</a><a href="#method.set_aliased_unchecked">set_aliased_unchecked</a><a href="#method.set_all">set_all</a><a href="#method.set_unchecked">set_unchecked</a><a href="#method.shift_left">shift_left</a><a href="#method.shift_right">shift_right</a><a href="#method.some">some</a><a href="#method.split">split</a><a href="#method.split_at">split_at</a><a href="#method.split_at_aliased_mut">split_at_aliased_mut</a><a href="#method.split_at_mut">split_at_mut</a><a href="#method.split_at_unchecked">split_at_unchecked</a><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a><a href="#method.split_first">split_first</a><a href="#method.split_first_mut">split_first_mut</a><a href="#method.split_last">split_last</a><a href="#method.split_last_mut">split_last_mut</a><a href="#method.split_mut">split_mut</a><a href="#method.splitn">splitn</a><a href="#method.splitn_mut">splitn_mut</a><a href="#method.starts_with">starts_with</a><a href="#method.swap">swap</a><a href="#method.swap_unchecked">swap_unchecked</a><a href="#method.swap_with_bitslice">swap_with_bitslice</a><a href="#method.trailing_ones">trailing_ones</a><a href="#method.trailing_zeros">trailing_zeros</a><a href="#method.windows">windows</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">AsMut&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">AsRef&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-Binary">Binary</a><a href="#impl-BitAnd%3CRhs%3E">BitAnd&lt;Rhs&gt;</a><a href="#impl-BitAndAssign%3CRhs%3E">BitAndAssign&lt;Rhs&gt;</a><a href="#impl-BitField">BitField</a><a href="#impl-BitOr%3CRhs%3E">BitOr&lt;Rhs&gt;</a><a href="#impl-BitOrAssign%3CRhs%3E">BitOrAssign&lt;Rhs&gt;</a><a href="#impl-BitXor%3CRhs%3E">BitXor&lt;Rhs&gt;</a><a href="#impl-BitXorAssign%3CRhs%3E">BitXorAssign&lt;Rhs&gt;</a><a href="#impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">Borrow&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">BorrowMut&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Deref">Deref</a><a href="#impl-DerefMut">DerefMut</a><a href="#impl-Display">Display</a><a href="#impl-Eq">Eq</a><a href="#impl-From%3CV%3E">From&lt;V&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-Index%3CIdx%3E">Index&lt;Idx&gt;</a><a href="#impl-IndexMut%3CIdx%3E">IndexMut&lt;Idx&gt;</a><a href="#impl-IntoIterator">IntoIterator</a><a href="#impl-LowerHex">LowerHex</a><a href="#impl-Not">Not</a><a href="#impl-Octal">Octal</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E">PartialEq&lt;BitArray&lt;O, V&gt;&gt;</a><a href="#impl-PartialEq%3CRhs%3E">PartialEq&lt;Rhs&gt;</a><a href="#impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E">PartialOrd&lt;BitArray&lt;O, V&gt;&gt;</a><a href="#impl-PartialOrd%3CRhs%3E">PartialOrd&lt;Rhs&gt;</a><a href="#impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">TryFrom&lt;&amp;&#39;a BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">TryFrom&lt;&amp;&#39;a mut BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UpperHex">UpperHex</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-Conv">Conv</a><a href="#impl-FmtForward">FmtForward</a><a href="#impl-From%3C!%3E">From&lt;!&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pipe">Pipe</a><a href="#impl-PipeAsRef">PipeAsRef</a><a href="#impl-PipeBorrow">PipeBorrow</a><a href="#impl-PipeDeref">PipeDeref</a><a href="#impl-PipeRef">PipeRef</a><a href="#impl-Tap">Tap</a><a href="#impl-TapAsRef%3CU%3E">TapAsRef&lt;U&gt;</a><a href="#impl-TapBorrow%3CU%3E">TapBorrow&lt;U&gt;</a><a href="#impl-TapDeref">TapDeref</a><a href="#impl-TryConv">TryConv</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="../index.html">bitvec</a>::<wbr><a href="index.html">array</a></p><div id="sidebar-vars" data-name="BitArray" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">array</a>::<wbr><a class="struct" href="">BitArray</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/bitvec/array.rs.html#149-158" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct"><span class="docblock attributes top-attr">#[repr(transparent)]</span>pub struct BitArray&lt;O&nbsp;=&nbsp;<a class="struct" href="../../bitvec/order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, V&nbsp;=&nbsp;[usize; 1]&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span> { /* fields omitted */ }</pre></div><div class="docblock"><p>An array of individual bits, able to be held by value on the stack.</p>
<p>This type is generic over all <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html"><code>Sized</code></a> implementors of the <a href="../../bitvec/view/trait.BitView.html"><code>BitView</code></a> trait.
Due to limitations in the Rust language’s const-generics implementation (it is
both unstable and incomplete), this must take an array type parameter directly,
rather than register type and bit-count integer parameters. This makes it less
convenient to use than C++’s <a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset&lt;N&gt;</code></a> array type. The <a href="../../bitvec/macro.bitarr.html"><code>bitarr!</code></a>
macro is capable of constructing both values and specific types of <code>BitArray</code>,
and this macro should be preferred for most use.</p>
<p>The advantage of using this wrapper is that it implements <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html"><code>Deref</code></a>/<a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html"><code>Mut</code></a> to
<a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>, as well as implementing all of <code>BitSlice</code>s traits by forwarding to
the <code>BitSlice</code> view of its contained data. This allows it to have <code>BitSlice</code>
behavior by itself, without requiring explicit <a href="../../bitvec/array/struct.BitArray.html#method.as_bitslice"><code>.as_bitslice()</code></a> calls in user
code.</p>
<h1 id="limitations" class="section-header"><a href="#limitations">Limitations</a></h1>
<p>This does not track start or end indices of its <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a> view, and so that
view will always fully span the buffer. You cannot produce, for example, an
array of twelve bits.</p>
<h1 id="type-parameters" class="section-header"><a href="#type-parameters">Type Parameters</a></h1>
<ul>
<li><code>O</code>: The ordering of bits within memory registers.</li>
<li><code>V</code>: Some buffer which can be used as the basis for a <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a> view. This
will usually be an array of <code>[T: BitRegister; N]</code>.</li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>This type is useful for marking that some value is always to be used as a
<a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">struct</span> <span class="ident">HasBitfields</span> {
  <span class="ident">header</span>: <span class="ident">u32</span>,
  <span class="comment">// creates a type declaration.</span>
  <span class="ident">fields</span>: <span class="macro">bitarr</span><span class="macro">!</span>(<span class="kw">for</span> <span class="number">20</span>, <span class="kw">in</span> <span class="ident">Msb0</span>, <span class="ident">u8</span>),
}

<span class="kw">impl</span> <span class="ident">HasBitfields</span> {
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
    <span class="self">Self</span> {
      <span class="ident">header</span>: <span class="number">0</span>,
      <span class="comment">// creates a value object.</span>
      <span class="comment">// the type paramaters must be repeated.</span>
      <span class="ident">fields</span>: <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">20</span>],
    }
  }

  <span class="doccomment">/// Access a bit region directly</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_subfield</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span> {
    <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">fields</span>[.. <span class="number">4</span>]
  }

  <span class="doccomment">/// Read a 12-bit value out of a region</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">read_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u16</span> {
    <span class="self">self</span>.<span class="ident">fields</span>[<span class="number">4</span> .. <span class="number">16</span>].<span class="ident">load</span>()
  }

  <span class="doccomment">/// Write a 12-bit value into a region</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_value</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">u16</span>) {
    <span class="self">self</span>.<span class="ident">fields</span>[<span class="number">4</span> .. <span class="number">16</span>].<span class="ident">store</span>(<span class="ident">value</span>);
  }
}</pre></div>
<h1 id="eventual-obsolescence" class="section-header"><a href="#eventual-obsolescence">Eventual Obsolescence</a></h1>
<p>When const-generics stabilize, this will be modified to have a signature more
like <code>BitArray&lt;O, T, const N: usize&gt;([T; elts::&lt;T&gt;(N)]);</code>, to mirror the
behavior of ordinary arrays <code>[T; N]</code> as they stand today.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/bitvec/array.rs.html#160-278" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.zeroed" class="method"><code>pub fn <a href="#method.zeroed" class="fnname">zeroed</a>() -&gt; Self</code><a class="srclink" href="../../src/bitvec/array.rs.html#167-172" title="goto source code">[src]</a></h4><div class="docblock"><p>Constructs a new <code>BitArray</code> with its memory set to zero.</p>
</div><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(data: V) -&gt; Self</code><a class="srclink" href="../../src/bitvec/array.rs.html#186-191" title="goto source code">[src]</a></h4><div class="docblock"><p>Wraps a buffer in a <code>BitArray</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let</span> <span class="ident">bits</span>: <span class="ident">BitArray</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitArray</span>::<span class="ident">new</span>(<span class="ident">data</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">16</span>);</pre></div>
</div><h4 id="method.value" class="method"><code>pub fn <a href="#method.value" class="fnname">value</a>(self) -&gt; V</code><a class="srclink" href="../../src/bitvec/array.rs.html#205-207" title="goto source code">[src]</a></h4><div class="docblock"><p>Removes the <code>BitArray</code> wrapper, leaving the contained buffer.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bitarr</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Lsb0</span>, <span class="ident">usize</span>; <span class="number">0</span>; <span class="number">30</span>];
<span class="kw">let</span> <span class="ident">native</span>: [<span class="ident">usize</span>; <span class="number">1</span>] <span class="op">=</span> <span class="ident">bitarr</span>.<span class="ident">value</span>();</pre></div>
</div><h4 id="method.as_bitslice" class="method"><code>pub fn <a href="#method.as_bitslice" class="fnname">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array.rs.html#214-216" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the array as a <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>.</p>
</div><h4 id="method.as_mut_bitslice" class="method"><code>pub fn <a href="#method.as_mut_bitslice" class="fnname">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array.rs.html#223-225" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the array as a mutable <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>.</p>
</div><h4 id="method.as_raw_slice" class="method"><code>pub fn <a href="#method.as_raw_slice" class="fnname">as_raw_slice</a>(&amp;self) -&gt; &amp;[V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>]</code><a class="srclink" href="../../src/bitvec/array.rs.html#229-236" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the array as a slice of its underlying memory registers.</p>
</div><h4 id="method.as_mut_raw_slice" class="method"><code>pub fn <a href="#method.as_mut_raw_slice" class="fnname">as_mut_raw_slice</a>(&amp;mut self) -&gt; &amp;mut [V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>]</code><a class="srclink" href="../../src/bitvec/array.rs.html#240-247" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the array as a mutable slice of its underlying memory registers.</p>
</div><h4 id="method.as_buffer" class="method"><code>pub fn <a href="#method.as_buffer" class="fnname">as_buffer</a>(&amp;self) -&gt; &amp;V</code><a class="srclink" href="../../src/bitvec/array.rs.html#268-270" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the interior buffer.</p>
</div><h4 id="method.as_mut_buffer" class="method"><code>pub fn <a href="#method.as_mut_buffer" class="fnname">as_mut_buffer</a>(&amp;mut self) -&gt; &amp;mut V</code><a class="srclink" href="../../src/bitvec/array.rs.html#275-277" title="goto source code">[src]</a></h4><div class="docblock"><p>Mutably views the interior buffer.</p>
</div></div><h2 id="deref-methods-BitSlice%3CO%2C%20V%3A%3AStore%3E" class="small-section-header">Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt;<a href="#deref-methods-BitSlice%3CO%2C%20V%3A%3AStore%3E" class="anchor"></a></h2><div class="impl-items"><h4 id="method.len" class="method"><code>pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#88-90" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of bits in the slice.</p>
<h1 id="original" class="section-header"><a href="#original">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre></div>
</div><h4 id="method.is_empty" class="method"><code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#107-109" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h1 id="original-1" class="section-header"><a href="#original-1">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">a</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.first" class="method"><code>pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#127-129" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first bit of the slice, or <code>None</code> if it is empty.</p>
<h1 id="original-2" class="section-header"><a href="#original-2">Original</a></h1><h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">v</span>.<span class="ident">first</span>().<span class="ident">as_deref</span>());

<span class="kw">let</span> <span class="ident">w</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">first</span>());</pre></div>
</div><h4 id="method.first_mut" class="method"><code>pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#160-162" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable pointer to the first bit of the slice, or <code>None</code>
if it is empty.</p>
<h1 id="original-3" class="section-header"><a href="#original-3">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h1 id="api-differences" class="section-header"><a href="#api-differences">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">first</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.split_first" class="method"><code>pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;, &amp;Self)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#185-193" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h1 id="original-4" class="section-header"><a href="#original-4">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first"><code>slice::split_first</code></a></p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_first</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">first</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rest</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}</pre></div>
</div><h4 id="method.split_first_mut" class="method"><code>pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#233-243" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h1 id="original-5" class="section-header"><a href="#original-5">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#split_first_mut"><code>slice::split_first_mut</code></a></p>
<h1 id="api-differences-1" class="section-header"><a href="#api-differences-1">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="ident">rest</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
  <span class="ident">rest</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.split_last" class="method"><code>pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;, &amp;Self)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#266-274" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h1 id="original-6" class="section-header"><a href="#original-6">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_last</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">last</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rest</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}</pre></div>
</div><h4 id="method.split_last_mut" class="method"><code>pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#314-324" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or
<code>None</code> if it is empty.</p>
<h1 id="original-7" class="section-header"><a href="#original-7">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h1 id="api-differences-2" class="section-header"><a href="#api-differences-2">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/slice/struct.BitSlice.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="ident">rest</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">false</span>);
  <span class="ident">rest</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.last" class="method"><code>pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#344-349" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last bit of the slice, or <code>None</code> if it is empty.</p>
<h1 id="original-8" class="section-header"><a href="#original-8">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">v</span>.<span class="ident">last</span>().<span class="ident">as_deref</span>());

<span class="kw">let</span> <span class="ident">w</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">last</span>());</pre></div>
</div><h4 id="method.last_mut" class="method"><code>pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/prelude/struct.BitRef.html" title="struct bitvec::prelude::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#379-384" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable pointer to the last bit in the slice.</p>
<h1 id="original-9" class="section-header"><a href="#original-9">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h1 id="api-differences-3" class="section-header"><a href="#api-differences-3">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">last</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.get" class="method"><code>pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#409-412" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to a bit or subslice depending on the type of index.</p>
<ul>
<li>If given a position, returns a reference to the bit at that position
or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range, or
<code>None</code> if out of bounds.</li>
</ul>
<h1 id="original-10" class="section-header"><a href="#original-10">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">as_deref</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span> .. <span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span> .. <span class="number">4</span>));</pre></div>
</div><h4 id="method.get_mut" class="method"><code>pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#444-447" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable reference to a bit or subslice depending on the type
of index (see <a href="../../bitvec/slice/struct.BitSlice.html#method.get"><code>.get()</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h1 id="original-11" class="section-header"><a href="#original-11">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h1 id="api-differences-4" class="section-header"><a href="#api-differences-4">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">bit</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">get_mut</span>(<span class="number">1</span>) {
  <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.get_unchecked" class="method"><code>pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#475-478" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to a bit or subslice, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the
resulting reference is not used. For a safe alternative, see <a href="../../bitvec/slice/struct.BitSlice.html#method.get"><code>.get()</code></a>.</p>
<h1 id="original-12" class="section-header"><a href="#original-12">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">unsafe</span> {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>), <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
}</pre></div>
</div><h4 id="method.get_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#517-520" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable reference to a bit or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="../../reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the
resulting reference is not used. For a safe alternative, see
[<code>.get_mut()</code>].</p>
<h1 id="original-13" class="section-header"><a href="#original-13">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h1 id="api-differences-5" class="section-header"><a href="#api-differences-5">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];
<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>);
  <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.swap" class="method"><code>pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: usize, b: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#579-585" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps two bits in the slice.</p>
<h1 id="original-14" class="section-header"><a href="#original-14">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h1 id="arguments" class="section-header"><a href="#arguments">Arguments</a></h1>
<ul>
<li><code>a</code>: The index of the first bit</li>
<li><code>b</code>: The index of the second bit</li>
</ul>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="ident">v</span>.<span class="ident">swap</span>(<span class="number">1</span>, <span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.reverse" class="method"><code>pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#603-633" title="goto source code">[src]</a></h4><div class="docblock"><p>Reverses the order of bits in the slice, in place.</p>
<h1 id="original-15" class="section-header"><a href="#original-15">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">v</span>.<span class="ident">reverse</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.iter" class="method"><code>pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;usize as <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;&gt;::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#672-674" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over the slice.</p>
<h1 id="original-16" class="section-header"><a href="#original-16">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h1 id="api-differences-6" class="section-header"><a href="#api-differences-6">API Differences</a></h1>
<p>This iterator yields <a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy references, rather than <code>&amp;bool</code>
ordinary references. It does so in order to promote consistency in the
crate, and make switching between immutable and mutable single-bit
access easier.</p>
<p>The produced iterator has a <a href="../../bitvec/slice/struct.Iter.html#method.by_ref"><code>by_ref</code></a> adapter that yields <code>&amp;bool</code>
references, and a <a href="../../bitvec/slice/struct.Iter.html#method.by_val"><code>by_val</code></a> adapter that yields <code>bool</code> values. Use
these methods to fit this iterator into APIs that expect ordinary <code>bool</code>
inputs.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iterator</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">iter</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id="method.iter_mut" class="method"><code>pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;usize as <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;&gt;::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#712-714" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator that allows modifying each bit.</p>
<h1 id="original-17" class="section-header"><a href="#original-17">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.iter_mut"><code>slice::iter_mut</code></a></p>
<h1 id="api-differences-7" class="section-header"><a href="#api-differences-7">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.IterMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">x</span>.<span class="ident">iter_mut</span>() {
  <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.windows" class="method"><code>pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#751-754" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over all contiguous windows of length <code>size</code>. The
windows overlap. If the slice is shorter than <code>size</code>, the iterator
returns no values.</p>
<h1 id="original-18" class="section-header"><a href="#original-18">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">windows</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">2</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the slice is shorter than <code>size</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">windows</span>(<span class="number">4</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.chunks" class="method"><code>pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#791-794" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> for the
same iterator but starting at the end of the slice.</p>
<h1 id="original-19" class="section-header"><a href="#original-19">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">chunks</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.chunks_mut" class="method"><code>pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#844-847" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> for
the same iterator but starting at the end of the slice.</p>
<h1 id="original-20" class="section-header"><a href="#original-20">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h1 id="api-differences-8" class="section-header"><a href="#api-differences-8">API Differences</a></h1>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.ChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">chunks_mut</span>(<span class="number">2</span>) {
  <span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
    <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="ident">count</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>;
  }
  <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.chunks_exact" class="method"><code>pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#890-893" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <a href="../../bitvec/slice/struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../../bitvec/slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> for the same
iterator but starting at the end of the slice.</p>
<h1 id="original-21" class="section-header"><a href="#original-21">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">chunks_exact</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]);</pre></div>
</div><h4 id="method.chunks_exact_mut" class="method"><code>pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: usize<br>) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#945-951" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <a href="../../bitvec/slice/struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a>
method of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> for a variant of this iterator that also returns
the remainder as a smaller chunk, and <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> for the
same iterator but starting at the end of the slice.</p>
<h1 id="original-22" class="section-header"><a href="#original-22">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h1 id="api-differences-9" class="section-header"><a href="#api-differences-9">API Differences</a></h1>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">2</span>) {
  <span class="ident">chunk</span>.<span class="ident">set_all</span>(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.rchunks" class="method"><code>pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#988-991" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h1 id="original-23" class="section-header"><a href="#original-23">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rchunks</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.rchunks_mut" class="method"><code>pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1041-1044" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> for
the same iterator but starting at the beginning of the slice.</p>
<h1 id="original-24" class="section-header"><a href="#original-24">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h1 id="api-differences-10" class="section-header"><a href="#api-differences-10">API Differences</a></h1>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.RChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rchunks_mut</span>(<span class="number">2</span>) {
  <span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
    <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="ident">count</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>;
  }
  <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.rchunks_exact" class="method"><code>pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1087-1090" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <a href="../../bitvec/slice/struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h1 id="original-25" class="section-header"><a href="#original-25">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rchunks_exact</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]);</pre></div>
</div><h4 id="method.rchunks_exact_mut" class="method"><code>pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: usize<br>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1142-1148" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <a href="../../bitvec/slice/struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a>
method of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may be
able to optimize the resulting code better than in the case of
<a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a>.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> for a variant of this iterator that also returns
the remainder as a smaller chunk, and <a href="../../bitvec/slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h1 id="original-26" class="section-header"><a href="#original-26">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rchunks_exact_mut"><code>slice::rchunks_exact_mut</code></a></p>
<h1 id="api-differences-11" class="section-header"><a href="#api-differences-11">API Differences</a></h1>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">2</span>) {
  <span class="ident">chunk</span>.<span class="ident">set_all</span>(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.split_at" class="method"><code>pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: usize) -&gt; (&amp;Self, &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1198-1202" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="original-27" class="section-header"><a href="#original-27">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="behavior" class="section-header"><a href="#behavior">Behavior</a></h1>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="macro">bits</span><span class="macro">!</span>[]);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="ident">v</span>);
}

{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">2</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>]);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);
}

{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">6</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="ident">v</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="macro">bits</span><span class="macro">!</span>[]);
}</pre></div>
</div><h4 id="method.split_at_mut" class="method"><code>pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: usize<br>) -&gt; (&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1265-1271" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="original-28" class="section-header"><a href="#original-28">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h1 id="api-differences-12" class="section-header"><a href="#api-differences-12">API Differences</a></h1>
<p>The partition index <code>mid</code> may occur anywhere in the slice, and as a
result the two returned slices may both have write access to the memory
address containing <code>mid</code>. As such, the returned slices must be marked
with <a href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias"><code>T::Alias</code></a> in order to correctly manage memory access going
forward.</p>
<p>This marking is applied to all memory accesses in both slices,
regardless of whether any future accesses actually require it. To limit
the alias marking to only the addresses that need it, use
[<code>.bit_domain()</code>] or [<code>.bit_domain_mut()</code>] to split either slice into
its aliased and unaliased subslices.</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="behavior-1" class="section-header"><a href="#behavior-1">Behavior</a></h1>
<p>When <code>mid</code> is <code>0</code> or <code>self.len()</code>, then the left or right return values,
respectively, are empty slices. Empty slice references produced by this
method are specified to have the address information you would expect:
a left empty slice has the same base address and start bit as <code>self</code>,
and a right empty slice will have its address raised by <code>self.len()</code>.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// scoped to restrict the lifetime of the borrows</span>
{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>]);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);

  <span class="ident">left</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
  <span class="ident">right</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.split" class="method"><code>pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1330-1333" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>.
The matched bit is not contained in the subslices.</p>
<h1 id="original-29" class="section-header"><a href="#original-29">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h1 id="api-differences-13" class="section-header"><a href="#api-differences-13">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">2</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the first bit is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last bit in the slice is
matched, an empty slice will be the last item returned by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If two matched bits are directly adjacent, an empty slice will be
present between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.split_mut" class="method"><code>pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1369-1372" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>. The matched bit is not contained in the subslices.</p>
<h1 id="original-30" class="section-header"><a href="#original-30">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h1 id="api-differences-14" class="section-header"><a href="#api-differences-14">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.SplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">split_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.rsplit" class="method"><code>pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1419-1422" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
starting at the end of the slice and working backwards. The matched bit
is not contained in the subslices.</p>
<h1 id="original-31" class="section-header"><a href="#original-31">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h1 id="api-differences-15" class="section-header"><a href="#api-differences-15">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">3</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>As with <a href="../../bitvec/slice/struct.BitSlice.html#method.split"><code>.split()</code></a>, if the first or last bit is matched, an empty
slice will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits</span><span class="macro">!</span>[]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.rsplit_mut" class="method"><code>pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1459-1462" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>, starting at the end of the slice and working backwards. The
matched bit is not contained in the subslices.</p>
<h1 id="original-32" class="section-header"><a href="#original-32">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h1 id="api-differences-16" class="section-header"><a href="#api-differences-16">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.RSplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplit_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.splitn" class="method"><code>pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1497-1500" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-33" class="section-header"><a href="#original-33">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h1 id="api-differences-17" class="section-header"><a href="#api-differences-17">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<p>Print the slice split once by set bits (i.e., <code>[0, 0,]</code>, <code>[0, 1, 0]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:b}&quot;</span>, <span class="ident">group</span>);
}</pre></div>
</div><h4 id="method.splitn_mut" class="method"><code>pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1540-1543" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-34" class="section-header"><a href="#original-34">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h1 id="api-differences-18" class="section-header"><a href="#api-differences-18">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.SplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">splitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.rsplitn" class="method"><code>pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1580-1583" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-35" class="section-header"><a href="#original-35">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h1 id="api-differences-19" class="section-header"><a href="#api-differences-19">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<p>Print the slice split once, starting from the end, by set bits (i.e.,
<code>[0]</code>, <code>[0, 0, 1, 0]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:b}&quot;</span>, <span class="ident">group</span>);
}</pre></div>
</div><h4 id="method.rsplitn_mut" class="method"><code>pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1624-1627" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-36" class="section-header"><a href="#original-36">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h1 id="api-differences-20" class="section-header"><a href="#api-differences-20">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<p>This iterator marks each yielded item as aliased, as iterators can be
used to yield multiple items into the same scope. If you are using
the iterator in a manner that ensures that all yielded items have
disjoint lifetimes, you can use the <a href="../../bitvec/slice/struct.RSplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter on it to
remove the alias marker from the yielded subslices.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.contains" class="method"><code>pub fn <a href="#method.contains" class="fnname">contains</a>&lt;O2, T2&gt;(&amp;self, x: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1664-1674" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if the slice contains a subslice that matches the given
span.</p>
<h1 id="original-37" class="section-header"><a href="#original-37">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h1 id="api-differences-21" class="section-header"><a href="#api-differences-21">API Differences</a></h1>
<p>This searches for a matching subslice (allowing different type
parameters) rather than for a specific bit. Searching for a contained
element with a given value is not as useful on a collection of <code>bool</code>.</p>
<p>Furthermore, <code>BitSlice</code> defines <a href="../../bitvec/slice/struct.BitSlice.html#method.any"><code>any</code></a> and <a href="../../bitvec/slice/struct.BitSlice.html#method.not_all"><code>not_all</code></a>, which are
optimized searchers for any <code>true</code> or <code>false</code> bit, respectively, in a
sequence.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0101_1010u8</span>;
<span class="kw">let</span> <span class="ident">bits_msb</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_lsb</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits_msb</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">bits_lsb</span>[<span class="number">1</span> .. <span class="number">5</span>]));</pre></div>
<p>This example uses a palindrome pattern to demonstrate that the slice
being searched for does not need to have the same type parameters as the
slice being searched.</p>
</div><h4 id="method.starts_with" class="method"><code>pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1705-1712" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p>
<h1 id="original-38" class="section-header"><a href="#original-38">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[]));
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="macro">bits</span><span class="macro">!</span>[]));</pre></div>
</div><h4 id="method.ends_with" class="method"><code>pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1743-1751" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p>
<h1 id="original-39" class="section-header"><a href="#original-39">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">2</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[]));
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="macro">bits</span><span class="macro">!</span>[]));</pre></div>
</div><h4 id="method.rotate_left" class="method"><code>pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1793-1826" title="goto source code">[src]</a></h4><div class="docblock"><p>Rotates the slice in-place such that the first <code>by</code> bits of the slice
move to the end while the last <code>self.len() - by</code> bits move to the
front. After calling <code>.rotate_left()</code>, the bit previously at index <code>by</code>
will become the first bit in the slice.</p>
<h1 id="original-40" class="section-header"><a href="#original-40">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_left"><code>slice::rotate_left</code></a></p>
<h1 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h1>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp.</p>
<h1 id="complexity" class="section-header"><a href="#complexity">Complexity</a></h1>
<p>Takes linear (in <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>) time.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="ident">a</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_left</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.rotate_right" class="method"><code>pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1868-1890" title="goto source code">[src]</a></h4><div class="docblock"><p>Rotates the slice in-place such that the first <code>self.len() - by</code> bits of
the slice move to the end while the last <code>by</code> bits move to the front.
After calling <code>.rotate_right()</code>, the bit previously at index `self.len()</p>
<ul>
<li>by` will become the first bit in the slice.</li>
</ul>
<h1 id="original-41" class="section-header"><a href="#original-41">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#rotate_right"><code>slice::rotate_right</code></a></p>
<h1 id="panics-13" class="section-header"><a href="#panics-13">Panics</a></h1>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp.</p>
<h1 id="complexity-1" class="section-header"><a href="#complexity-1">Complexity</a></h1>
<p>Takes linear (in <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>) time.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="ident">a</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_right</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.copy_within" class="method"><code>pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: usize) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1944-1955" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h1 id="original-42" class="section-header"><a href="#original-42">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h1 id="panics-14" class="section-header"><a href="#panics-14">Panics</a></h1>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<p>Copying four bits within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="ident">bits</span>.<span class="ident">copy_within</span>(<span class="number">1</span> .. <span class="number">5</span>, <span class="number">8</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.align_to" class="method"><code>pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; (&amp;Self, &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, &amp;Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2038-2046" title="goto source code">[src]</a></h4><div class="docblock"><p>Transmute the bit-slice to a bit-slice of another type, ensuring
alignment of the types is maintained.</p>
<h1 id="original-43" class="section-header"><a href="#original-43">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h1 id="api-differences-22" class="section-header"><a href="#api-differences-22">API Differences</a></h1>
<p>Type <code>U</code> is <strong>required</strong> to have the same <a href="../../bitvec/store/trait.BitStore.html"><code>BitStore</code></a> type family as
type <code>T</code>. If <code>T</code> is a fundamental integer, so must <code>U</code> be; if <code>T</code> is an
<a href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias"><code>::Alias</code></a> type, then so must <code>U</code>. Changing the type family with this
method is <strong>unsound</strong> and strictly forbidden. Unfortunately, this cannot
be encoded in the type system, so you are required to abide by this
limitation yourself.</p>
<h1 id="implementation" class="section-header"><a href="#implementation">Implementation</a></h1>
<p>The algorithm used to implement this function attempts to create the
widest possible span for the middle slice. However, the slice divisions
must abide by the <a href="../../bitvec/domain/enum.Domain.html"><code>Domain</code></a> restrictions: the left and right slices
produced by this function will include the head and tail elements of the
domain (if present), as well as the left and right subslices (if any)
produced by calling <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a> on the domain body (if present).</p>
<p>The standard library implementation currently maximizes the width of the
center slice, but its API does not guarantee this property, and retains
the right to produce pessimal slices. As such, this function cannot
guarantee maximal center slice width either, and you cannot rely on this
behavior for <em>correctness</em> of your work; it is only a possible
performance improvement.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>This method is essentially a <a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.transmute.html"><code>mem::transmute</code></a> with respect to the
memory region in the retured middle slice, so all of the usual caveats
pertaining to <a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.transmute.html"><code>mem::transmute::&lt;T, U&gt;</code></a> also apply here.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
  <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
  <span class="kw">match</span> <span class="ident">prefix</span>.<span class="ident">len</span>() {
    <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> {
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[.. <span class="number">48</span>]);
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suffix</span>, <span class="ident">bits</span>[<span class="number">48</span> ..]);
    },
    <span class="number">8</span> <span class="op">=</span><span class="op">&gt;</span> {
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">prefix</span>, <span class="ident">bits</span>[.. <span class="number">8</span>]);
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[<span class="number">8</span> ..]);
    },
    <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">unreachable</span><span class="macro">!</span>(<span class="string">&quot;This case will not occur&quot;</span>)
  }
}</pre></div>
</div><h4 id="method.align_to_mut" class="method"><code>pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; (&amp;mut Self, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, &amp;mut Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2108-2118" title="goto source code">[src]</a></h4><div class="docblock"><p>Transmute the bit-slice to a bit-slice of another type, ensuring
alignment of the types is maintained.</p>
<h1 id="original-44" class="section-header"><a href="#original-44">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a></p>
<h1 id="api-differences-23" class="section-header"><a href="#api-differences-23">API Differences</a></h1>
<p>Type <code>U</code> is <strong>required</strong> to have the same <a href="../../bitvec/store/trait.BitStore.html"><code>BitStore</code></a> type family as
type <code>T</code>. If <code>T</code> is a fundamental integer, so must <code>U</code> be; if <code>T</code> is an
<a href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias"><code>::Alias</code></a> type, then so must <code>U</code>. Changing the type family with this
method is <strong>unsound</strong> and strictly forbidden. Unfortunately, this cannot
be encoded in the type system, so you are required to abide by this
limitation yourself.</p>
<h1 id="implementation-1" class="section-header"><a href="#implementation-1">Implementation</a></h1>
<p>The algorithm used to implement this function attempts to create the
widest possible span for the middle slice. However, the slice divisions
must abide by the <a href="../../bitvec/domain/enum.DomainMut.html"><code>DomainMut</code></a> restrictions: the left and right slices
produced by this function will include the head and tail elements of the
domain (if present), as well as the left and right subslices (if any)
produced by calling <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a> on the domain body (if
present).</p>
<p>The standard library implementation currently maximizes the width of the
center slice, but its API does not guarantee this property, and retains
the right to produce pessimal slices. As such, this function cannot
guarantee maximal center slice width either, and you cannot rely on this
behavior for <em>correctness</em> of your work; it is only a possible
performance improvement.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>This method is essentially a <a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.transmute.html"><code>mem::transmute</code></a> with respect to the
memory region in the retured middle slice, so all of the usual caveats
pertaining to <a href="https://doc.rust-lang.org/nightly/core/intrinsics/fn.transmute.html"><code>mem::transmute::&lt;T, U&gt;</code></a> also apply here.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
  <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to_mut</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
  <span class="comment">//  same access and behavior as in `align_to`</span>
}</pre></div>
</div></div><div class="impl-items"><h4 id="method.set" class="method"><code>pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: usize, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#761-766" title="goto source code">[src]</a></h4><div class="docblock"><p>Writes a new bit at a given index.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h1 id="effects" class="section-header"><a href="#effects">Effects</a></h1>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.</p>
<h1 id="panics-15" class="section-header"><a href="#panics-15">Panics</a></h1>
<p>This method panics if <code>index</code> is not less than <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);</pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>];
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);</pre></div>
</div><h4 id="method.set_aliased" class="method"><code>pub fn <a href="#method.set_aliased" class="fnname">set_aliased</a>(&amp;self, index: usize, value: bool) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#820-826" title="goto source code">[src]</a></h4><div class="docblock"><p>Writes a new bit at a given index.</p>
<p>This method supports writing through a shared reference to a bit that
may be observed by other <code>BitSlice</code> handles. It is only present when the
<code>T</code> type parameter supports such shared mutation (measured by the
<a href="../../radium/trait.Radium.html"><code>Radium</code></a> trait).</p>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h1 id="effects-1" class="section-header"><a href="#effects-1">Effects</a></h1>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.
If <code>T</code> is an <a href="https://doc.rust-lang.org/nightly/core/sync/atomic/index.html">atomic</a>, this will lock the memory bus for the referent
address, and may cause stalls.</p>
<h1 id="panics-16" class="section-header"><a href="#panics-16">Panics</a></h1>
<p>This method panics if <code>index</code> is not less than <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="kw">let</span> <span class="ident">byte</span> <span class="op">=</span> <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">0u8</span>);
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">byte</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_2</span> <span class="op">=</span> <span class="ident">bits</span>;

<span class="ident">bits</span>.<span class="ident">set_aliased</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits_2</span>[<span class="number">1</span>]);</pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="kw">let</span> <span class="ident">byte</span> <span class="op">=</span> <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">0u8</span>);
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">byte</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">set_aliased</span>(<span class="number">8</span>, <span class="bool-val">false</span>);</pre></div>
</div><h4 id="method.any" class="method"><code>pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#857-871" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h1 id="truth-table" class="section-header"><a href="#truth-table">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns" class="section-header"><a href="#returns">Returns</a></h1>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">any</span>());</pre></div>
</div><h4 id="method.all" class="method"><code>pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#902-930" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h1 id="truth-table-1" class="section-header"><a href="#truth-table-1">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-3" class="section-header"><a href="#parameters-3">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-1" class="section-header"><a href="#returns-1">Returns</a></h1>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">all</span>());</pre></div>
</div><h4 id="method.not_any" class="method"><code>pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#960-962" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h1 id="truth-table-2" class="section-header"><a href="#truth-table-2">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-4" class="section-header"><a href="#parameters-4">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-2" class="section-header"><a href="#returns-2">Returns</a></h1>
<p>Whether all bits in the slice domain are unset.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">not_any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">not_any</span>());</pre></div>
</div><h4 id="method.not_all" class="method"><code>pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#992-994" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h1 id="truth-table-3" class="section-header"><a href="#truth-table-3">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-5" class="section-header"><a href="#parameters-5">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-3" class="section-header"><a href="#returns-3">Returns</a></h1>
<p>Whether any bit in the slice domain is unset.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">not_all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">not_all</span>());</pre></div>
</div><h4 id="method.some" class="method"><code>pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1034-1036" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <a href="../../bitvec/slice/struct.BitSlice.html#method.all"><code>.all()</code></a> or <a href="../../bitvec/slice/struct.BitSlice.html#method.not_any"><code>.not_any()</code></a> are <code>true</code>.</p>
<h1 id="truth-table-4" class="section-header"><a href="#truth-table-4">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-6" class="section-header"><a href="#parameters-6">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-4" class="section-header"><a href="#returns-4">Returns</a></h1>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b111_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">4</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">some</span>());</pre></div>
</div><h4 id="method.count_ones" class="method"><code>pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1059-1081" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the slice contents.</p>
<h1 id="parameters-7" class="section-header"><a href="#parameters-7">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-5" class="section-header"><a href="#returns-5">Returns</a></h1>
<p>The number of bits in the slice domain that are set to <code>1</code>.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">count_ones</span>(), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">count_ones</span>(), <span class="number">0</span>);</pre></div>
</div><h4 id="method.count_zeros" class="method"><code>pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1104-1126" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the slice contents.</p>
<h1 id="parameters-8" class="section-header"><a href="#parameters-8">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-6" class="section-header"><a href="#returns-6">Returns</a></h1>
<p>The number of bits in the slice domain that are cleared to <code>0</code>.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">count_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">count_zeros</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id="method.iter_ones" class="method"><code>pub fn <a href="#method.iter_ones" class="fnname">iter_ones</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = usize;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1151-1153" title="goto source code">[src]</a></h4><div class="docblock"><p>Enumerates all bits in a <code>BitSlice</code> that are set to <code>1</code>.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">indices</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].<span class="ident">iter</span>().<span class="ident">copied</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter_ones</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter_ones</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">compose</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>()
  .<span class="ident">copied</span>()
  .<span class="ident">enumerate</span>()
  .<span class="ident">filter_map</span>(<span class="op">|</span>(<span class="ident">idx</span>, <span class="ident">bit</span>)<span class="op">|</span> <span class="kw">if</span> <span class="ident">bit</span> { <span class="prelude-val">Some</span>(<span class="ident">idx</span>) } <span class="kw">else</span> { <span class="prelude-val">None</span> });

<span class="kw">for</span> ((<span class="ident">a</span>, <span class="ident">b</span>), <span class="ident">c</span>) <span class="kw">in</span> <span class="ident">iter_ones</span>.<span class="ident">zip</span>(<span class="ident">compose</span>).<span class="ident">zip</span>(<span class="ident">indices</span>) {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">b</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b</span>, <span class="ident">c</span>);
}</pre></div>
</div><h4 id="method.iter_zeros" class="method"><code>pub fn <a href="#method.iter_zeros" class="fnname">iter_zeros</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = usize;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1178-1180" title="goto source code">[src]</a></h4><div class="docblock"><p>Enumerates all bits in a <code>BitSlice</code> that are cleared to <code>0</code>.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">indices</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].<span class="ident">iter</span>().<span class="ident">copied</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter_zeros</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter_zeros</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">compose</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>()
  .<span class="ident">copied</span>()
  .<span class="ident">enumerate</span>()
  .<span class="ident">filter_map</span>(<span class="op">|</span>(<span class="ident">idx</span>, <span class="ident">bit</span>)<span class="op">|</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">bit</span> { <span class="prelude-val">Some</span>(<span class="ident">idx</span>) } <span class="kw">else</span> { <span class="prelude-val">None</span> });

<span class="kw">for</span> ((<span class="ident">a</span>, <span class="ident">b</span>), <span class="ident">c</span>) <span class="kw">in</span> <span class="ident">iter_zeros</span>.<span class="ident">zip</span>(<span class="ident">compose</span>).<span class="ident">zip</span>(<span class="ident">indices</span>) {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, <span class="ident">b</span>);
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">b</span>, <span class="ident">c</span>);
}</pre></div>
</div><h4 id="method.first_one" class="method"><code>pub fn <a href="#method.first_one" class="fnname">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;usize&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1193-1195" title="goto source code">[src]</a></h4><div class="docblock"><p>Gets the index of the first bit in the bit-slice set to <code>1</code>.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">first_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>].<span class="ident">first_one</span>().<span class="ident">unwrap</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id="method.first_zero" class="method"><code>pub fn <a href="#method.first_zero" class="fnname">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;usize&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1208-1210" title="goto source code">[src]</a></h4><div class="docblock"><p>Gets the index of the first bit in the bit-slice set to <code>0</code>.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">first_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>].<span class="ident">first_zero</span>().<span class="ident">unwrap</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id="method.last_one" class="method"><code>pub fn <a href="#method.last_one" class="fnname">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;usize&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1223-1225" title="goto source code">[src]</a></h4><div class="docblock"><p>Gets the index of the last bit in the bit-slice set to <code>1</code>.</p>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">last_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>].<span class="ident">last_one</span>().<span class="ident">unwrap</span>(), <span class="number">3</span>);</pre></div>
</div><h4 id="method.last_zero" class="method"><code>pub fn <a href="#method.last_zero" class="fnname">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;usize&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1238-1240" title="goto source code">[src]</a></h4><div class="docblock"><p>Gets the index of the last bit in the bit-slice set to <code>0</code>.</p>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">last_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>].<span class="ident">last_zero</span>().<span class="ident">unwrap</span>(), <span class="number">3</span>);</pre></div>
</div><h4 id="method.leading_ones" class="method"><code>pub fn <a href="#method.leading_ones" class="fnname">leading_ones</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1258-1260" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">leading_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>].<span class="ident">leading_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>].<span class="ident">leading_ones</span>(), <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>].<span class="ident">leading_ones</span>(), <span class="number">4</span>);</pre></div>
</div><h4 id="method.leading_zeros" class="method"><code>pub fn <a href="#method.leading_zeros" class="fnname">leading_zeros</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1278-1280" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">leading_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>].<span class="ident">leading_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>].<span class="ident">leading_zeros</span>(), <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].<span class="ident">leading_zeros</span>(), <span class="number">4</span>);</pre></div>
</div><h4 id="method.trailing_ones" class="method"><code>pub fn <a href="#method.trailing_ones" class="fnname">trailing_ones</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1297-1300" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">trailing_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>].<span class="ident">trailing_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>].<span class="ident">trailing_ones</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id="method.trailing_zeros" class="method"><code>pub fn <a href="#method.trailing_zeros" class="fnname">trailing_zeros</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1317-1320" title="goto source code">[src]</a></h4><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[].<span class="ident">trailing_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>].<span class="ident">trailing_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>].<span class="ident">trailing_zeros</span>(), <span class="number">2</span>);</pre></div>
</div><h4 id="method.clone_from_bitslice" class="method"><code>pub fn <a href="#method.clone_from_bitslice" class="fnname">clone_from_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1394-1418" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as `self.</p>
<p>If <code>src</code> has the same type arguments as <code>self</code>, it can be more
performant to use <a href="../../bitvec/slice/struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>.</p>
<h1 id="original-45" class="section-header"><a href="#original-45">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_bitslice"><code>slice::clone_from_bitslice</code></a></p>
<h1 id="api-differences-24" class="section-header"><a href="#api-differences-24">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h1 id="panics-17" class="section-header"><a href="#panics-17">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<p>Cloning two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="ident">Msb0</span>, <span class="ident">u16</span>; <span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">dst</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="ident">Lsb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">2</span>];

<span class="ident">dst</span>.<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">2</span> ..]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dst</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">2</span>]);</pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use clone_from_slice on a single
slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">slice</span>[.. <span class="number">2</span>].<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">slice</span>[<span class="number">3</span> ..]); <span class="comment">// compile fail!</span></pre></div>
<p>To work around this, we can use <a href="../../bitvec/slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> to create two
distinct sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
  <span class="ident">left</span>.<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">right</span>[<span class="number">1</span> ..]);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
<h1 id="performance" class="section-header"><a href="#performance">Performance</a></h1>
<p>If <code>self</code> and <code>src</code> use the same type arguments, this specializes to
<a href="../../bitvec/slice/struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>; if you know statically that this is the case,
prefer to call that method directly and avoid the cost of detection at
runtime. Otherwise, this is a bit-by-bit crawl across both slices, which
is a slow process.</p>
</div><h4 id="method.copy_from_bitslice" class="method"><code>pub fn <a href="#method.copy_from_bitslice" class="fnname">copy_from_bitslice</a>(&amp;mut self, src: &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1488-1593" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>, using a memcpy wherever
possible.</p>
<p>The length of <code>src</code> must be same as <code>self</code>.</p>
<p>If <code>src</code> does not use the same type arguments as <code>self</code>, use
<a href="../../bitvec/slice/struct.BitSlice.html#method.clone_from_bitslice"><code>.clone_from_bitslice()</code></a>.</p>
<h1 id="original-46" class="section-header"><a href="#original-46">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h1 id="api-differences-25" class="section-header"><a href="#api-differences-25">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h1 id="panics-18" class="section-header"><a href="#panics-18">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<p>Copying two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">dst</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">2</span>];

<span class="comment">// Because the slices have to be the same length,</span>
<span class="comment">// we slice the source slice from four bits to</span>
<span class="comment">// two. It will panic if we don&#39;t do this.</span>
<span class="ident">dst</span>.<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">2</span>..]);</pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use [.copy_from_slice()] on a
single slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

<span class="ident">slice</span>[.. <span class="number">2</span>].<span class="ident">copy_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> ..]); <span class="comment">// compile fail!</span></pre></div>
<p>To work around this, we can use <a href="../../bitvec/slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> to create two
distinct sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];

{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
  <span class="ident">left</span>.<span class="ident">copy_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">right</span>[<span class="number">1</span> ..]);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.swap_with_bitslice" class="method"><code>pub fn <a href="#method.swap_with_bitslice" class="fnname">swap_with_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1629-1645" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps all bits in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h1 id="original-47" class="section-header"><a href="#original-47">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h1 id="api-differences-26" class="section-header"><a href="#api-differences-26">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h1 id="panics-19" class="section-header"><a href="#panics-19">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one</span> <span class="op">=</span> [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">two</span> <span class="op">=</span> <span class="number">0x1234u16</span>;
<span class="kw">let</span> <span class="ident">one_bits</span> <span class="op">=</span> <span class="ident">one</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">two_bits</span> <span class="op">=</span> <span class="ident">two</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="ident">one_bits</span>.<span class="ident">swap_with_bitslice</span>(<span class="ident">two_bits</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">one</span>, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">two</span>, <span class="number">0x96A5</span>);</pre></div>
</div><h4 id="method.shift_left" class="method"><code>pub fn <a href="#method.shift_left" class="fnname">shift_left</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1672-1689" title="goto source code">[src]</a></h4><div class="docblock"><p>Shifts the contents of a bit-slice left (towards index <code>0</code>).</p>
<p>This moves the contents of the slice from <code>by ..</code> down to
<code>0 .. len - by</code>, and erases <code>len - by ..</code> to <code>0</code>. As this is a
destructive (and linearly expensive) operation, you may prefer instead
to use range subslicing.</p>
<h1 id="parameters-9" class="section-header"><a href="#parameters-9">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The distance by which to shift the slice contents.</li>
</ul>
<h1 id="panics-20" class="section-header"><a href="#panics-20">Panics</a></h1>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">1</span>; <span class="number">6</span>];
<span class="ident">bits</span>.<span class="ident">shift_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id="method.shift_right" class="method"><code>pub fn <a href="#method.shift_right" class="fnname">shift_right</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1715-1732" title="goto source code">[src]</a></h4><div class="docblock"><p>Shifts the contents of a bit-slice right (towards index <code>self.len()</code>).</p>
<p>This moves the contents of the slice from <code>.. len - by</code> up to <code>by ..</code>,
and erases <code>.. by</code> to <code>0</code>. As this is a destructive (and linearly
expensive) operation, you may prefer instead to use range subslicing.</p>
<h1 id="parameters-10" class="section-header"><a href="#parameters-10">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>by</code>: The distance by which to shift the slice contents.</li>
</ul>
<h1 id="panics-21" class="section-header"><a href="#panics-21">Panics</a></h1>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h1 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">1</span>; <span class="number">6</span>];
<span class="ident">bits</span>.<span class="ident">shift_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.set_all" class="method"><code>pub fn <a href="#method.set_all" class="fnname">set_all</a>(&amp;mut self, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1755-1779" title="goto source code">[src]</a></h4><div class="docblock"><p>Sets all bits in the slice to a value.</p>
<h1 id="parameters-11" class="section-header"><a href="#parameters-11">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h1 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
<span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">5</span>].<span class="ident">set_all</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
<span class="ident">bits</span>[.. <span class="number">1</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</pre></div>
</div><h4 id="method.for_each" class="method"><code>pub fn <a href="#method.for_each" class="fnname">for_each</a>&lt;F&gt;(&amp;mut self, func: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1814-1823" title="goto source code">[src]</a></h4><div class="docblock"><p>Applies a function to each bit in the slice.</p>
<p><code>BitSlice</code> cannot implement <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html"><code>IndexMut</code></a>, as it cannot manifest <code>&amp;mut bool</code> references, and the <a href="../../bitvec/prelude/struct.BitRef.html"><code>BitRef</code></a> proxy reference has an unavoidable
overhead. This method bypasses both problems, by applying a function to
each pair of index and value in the slice, without constructing a proxy
reference. Benchmarks indicate that this method is about 2–4 times
faster than the <code>.iter_mut().enumerate()</code> equivalent.</p>
<h1 id="parameters-12" class="section-header"><a href="#parameters-12">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives two arguments, <code>index: usize</code> and
<code>value: bool</code>, and returns a <code>bool</code>.</li>
</ul>
<h1 id="effects-2" class="section-header"><a href="#effects-2">Effects</a></h1>
<p>For each index in the slice, the result of invoking <code>func</code> with the
index number and current bit value is written into the slice.</p>
<h1 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">idx</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b100_100_10</span>);</pre></div>
</div><h4 id="method.offset_from" class="method"><code>pub fn <a href="#method.offset_from" class="fnname">offset_from</a>(&amp;self, other: &amp;Self) -&gt; isize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1872-1874" title="goto source code">[src]</a></h4><div class="docblock"><p>Produces the absolute offset in bits between two slice heads.</p>
<p>While this method is sound for any two arbitrary bit slices, the answer
it produces is meaningful <em>only</em> when one argument is a strict subslice
of the other. If the two slices are created from different buffers
entirely, a comparison is undefined; if the two slices are disjoint
regions of the same buffer, then the semantically correct distance is
between the tail of the lower and the head of the upper, which this
does not measure.</p>
<h1 id="visual-description" class="section-header"><a href="#visual-description">Visual Description</a></h1>
<p>Consider the following sequence of bits:</p>
<pre><code class="language-text">[ 0 1 2 3 4 5 6 7 8 9 a b ]
  |       ^^^^^^^       |
  ^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>It does not matter whether there are bits between the tail of the
smaller and the larger slices. The offset is computed from the bit
distance between the two heads.</p>
<h1 id="behavior-2" class="section-header"><a href="#behavior-2">Behavior</a></h1>
<p>This function computes the <em>semantic</em> distance between the heads, rather
than the *electrical. It does not take into account the <code>BitOrder</code>
implementation of the slice.</p>
<h1 id="safety-and-soundness" class="section-header"><a href="#safety-and-soundness">Safety and Soundness</a></h1>
<p>One of <code>self</code> or <code>other</code> must contain the other for this comparison to
be meaningful.</p>
<h1 id="parameters-13" class="section-header"><a href="#parameters-13">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>other</code>: Another bit slice. This must be either a strict subregion or
a strict superregion of <code>self</code>.</li>
</ul>
<h1 id="returns-7" class="section-header"><a href="#returns-7">Returns</a></h1>
<p>The distance in (semantic) bits betwen the heads of each region. The
value is positive when <code>other</code> is higher in the address space than
<code>self</code>, and negative when <code>other</code> is lower in the address space than
<code>self</code>.</p>
</div></div><div class="impl-items"><h4 id="method.set_unchecked" class="method"><code>pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: usize, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1944-1946" title="goto source code">[src]</a></h4><div class="docblock"><p>Writes a new bit at a given index, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! Calling this method
with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>. For a safe
alternative, see <a href="../../bitvec/slice/struct.BitSlice.html#method.set"><code>.set()</code></a>.</p>
<h1 id="parameters-14" class="section-header"><a href="#parameters-14">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index at which to write. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be written; <code>true</code> for <code>1</code> or <code>false</code> for <code>0</code>.</li>
</ul>
<h1 id="effects-3" class="section-header"><a href="#effects-3">Effects</a></h1>
<p>The bit at <code>index</code> is set to <code>value</code>. If <code>index</code> is out of bounds, then
the memory access is incorrect, and its behavior is unspecified.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h1 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h1>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">2</span>];
<span class="kw">let</span> (<span class="ident">first</span>, <span class="kw">_</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">1</span>);

<span class="kw">unsafe</span> {
  <span class="ident">first</span>.<span class="ident">set_unchecked</span>(<span class="number">1</span>, <span class="bool-val">true</span>);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>, <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id="method.set_aliased_unchecked" class="method"><code>pub unsafe fn <a href="#method.set_aliased_unchecked" class="fnname">set_aliased_unchecked</a>(&amp;self, index: usize, value: bool) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1992-1995" title="goto source code">[src]</a></h4><div class="docblock"><p>Writes a new bit at a given index, without doing bounds checking.</p>
<p>This method supports writing through a shared reference to a bit that
may be observed by other <code>BitSlice</code> handles. It is only present when the
<code>T</code> type parameter supports such shared mutation (measured by the
<a href="../../radium/trait.Radium.html"><code>Radium</code></a> trait).</p>
<h1 id="effects-4" class="section-header"><a href="#effects-4">Effects</a></h1>
<p>The bit at <code>index</code> is set to <code>value</code>. If <code>index</code> is out of bounds, then
the memory access is incorrect, and its behavior is unspecified. If <code>T</code>
is an <a href="https://doc.rust-lang.org/nightly/core/sync/atomic/index.html">atomic</a>, this will lock the memory bus for the referent
address, and may cause stalls.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h1 id="examples-75" class="section-header"><a href="#examples-75">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">cell</span>::<span class="ident">Cell</span>;

<span class="kw">let</span> <span class="ident">byte</span> <span class="op">=</span> <span class="ident">Cell</span>::<span class="ident">new</span>(<span class="number">0u8</span>);
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">byte</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_2</span> <span class="op">=</span> <span class="ident">bits</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="kw">_</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">first</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="kw">unsafe</span> { <span class="ident">first</span>.<span class="ident">set_aliased_unchecked</span>(<span class="number">2</span>, <span class="bool-val">true</span>); }

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits_2</span>[<span class="number">2</span>]);</pre></div>
</div><h4 id="method.swap_unchecked" class="method"><code>pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: usize, b: usize)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2007-2012" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps two bits in the slice.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.swap"><code>.swap()</code></a>.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p><code>a</code> and <code>b</code> must both be less than <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div><h4 id="method.split_at_unchecked" class="method"><code>pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: usize) -&gt; (&amp;Self, &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2041-2043" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one slice into two at an index, without performing any bounds
checking.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.split_at"><code>.split_at()</code></a>.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p><code>mid</code> must not be greater than <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>. If this condition is
violated, the function behavior is <em>unspecified</em>.</p>
<h1 id="examples-76" class="section-header"><a href="#examples-76">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">split_at_unchecked</span>(<span class="number">3</span>) };
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">l</span>.<span class="ident">not_any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">r</span>.<span class="ident">all</span>());

<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">r</span>) <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">split_at_unchecked</span>(<span class="number">6</span>) };
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">l</span>, <span class="ident">bits</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">r</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.split_at_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fnname">split_at_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: usize<br>) -&gt; (&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2056-2065" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a>.</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p><code>mid</code> must not be greater than <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div><h4 id="method.copy_within_unchecked" class="method"><code>pub unsafe fn <a href="#method.copy_within_unchecked" class="fnname">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: usize) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#2088-2116" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies bits from one part of the slice to another part of itself,
without doing bounds checks.</p>
<p>The ranges are allowed to overlap.</p>
<h1 id="parameters-15" class="section-header"><a href="#parameters-15">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: The range within <code>self</code> from which to copy.</li>
<li><code>dst</code>: The starting index within <code>self</code> at which to paste.</li>
</ul>
<h1 id="effects-5" class="section-header"><a href="#effects-5">Effects</a></h1>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.end() - src.start()]</code>.</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p><code>src</code> and <code>dest .. dest + src.len()</code> must be entirely within
<a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a>.</p>
</div></div><div class="impl-items"><h4 id="method.as_bitptr" class="method"><code>pub fn <a href="#method.as_bitptr" class="fnname">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2171-2173" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a raw bit-pointer to the base of the bit-slice’s region.</p>
<p>The caller must ensure that the bit-slice outlives the bit-pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the bit-pointer
(non-transitively) points to is never written to using this bit-pointer
or any bit-pointer derived from it. If you need to mutate the contents
of the slice, use <a href="../../bitvec/slice/struct.BitSlice.html#method.as_mut_bitptr"><code>.as_mut_bitptr()</code></a>.</p>
<p>Modifying the container referenced by this bit-slice may cause its
buffer to be reällocated, which would also make any bit-pointers to it
invalid.</p>
<h1 id="original-48" class="section-header"><a href="#original-48">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h1 id="api-differences-27" class="section-header"><a href="#api-differences-27">API Differences</a></h1>
<p>This returns a structure, <a href="../../bitvec/prelude/struct.BitPtr.html" title="BitPtr"><code>BitPtr</code></a>, rather than an actual raw pointer
<code>*Bit</code>. The information required to address a bit within a memory
element cannot be encoded into a single pointer.</p>
<p>This structure can be converted back into a <code>&amp;BitSlice</code> with the
function <a href="../../bitvec/slice/fn.from_raw_parts.html"><code>from_raw_parts</code></a>.</p>
<h1 id="examples-77" class="section-header"><a href="#examples-77">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">x_ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
  <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">x</span>.<span class="ident">len</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="ident">i</span>), (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>)[<span class="ident">i</span>]);
  }
}</pre></div>
</div><h4 id="method.as_mut_bitptr" class="method"><code>pub fn <a href="#method.as_mut_bitptr" class="fnname">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="../../bitvec/prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2211-2213" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an unsafe mutable bit-pointer to the bit-slice’s region.</p>
<p>The caller must ensure that the bit-slice outlives the bit-pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container referenced by this bit-slice may cause its
buffer to be reällocated, which would also make any bit-pointers to it
invalid.</p>
<h1 id="original-49" class="section-header"><a href="#original-49">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h1 id="api-differences-28" class="section-header"><a href="#api-differences-28">API Differences</a></h1>
<p>This returns <code>*mut BitSlice</code>, which is the equivalont of <code>*mut [T]</code>
instead of <code>*mut T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h1 id="examples-78" class="section-header"><a href="#examples-78">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="ident">Lsb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">8</span>];
<span class="kw">let</span> <span class="ident">bits_ptr</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">bits</span>.<span class="ident">len</span>() {
  <span class="kw">unsafe</span> {
    <span class="ident">bits_ptr</span>.<span class="ident">add</span>(<span class="ident">i</span>).<span class="ident">write</span>(<span class="ident">i</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
  }
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0b0100_1001</span>);</pre></div>
</div><h4 id="method.as_bitptr_range" class="method"><code>pub fn <a href="#method.as_bitptr_range" class="fnname">as_bitptr_range</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../../bitvec/ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;M, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: Mutability,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = <a class="struct" href="../../bitvec/prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;M, O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#2258-2260" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the two raw bit-pointers spanning the bit-slice.</p>
<p>The returned range is half-open, which means that the end bit-pointer
points <em>one past</em> the last bit of the bit-slice. This way, an empty
bit-slice is represented by two equal bit-pointers, and the difference
between the two bit-pointers represents the size of the bit-slice.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.as_bitptr"><code>as_bitptr</code></a> for warnings on using these bit-pointers. The end
bit-pointer requires extra caution, as it does not point to a valid bit
in the bit-slice.</p>
<p>This function allows a more direct access to bit-pointers, without
paying the cost of encoding into a <code>*BitSlice</code>, at the cost of no longer
fitting into ordinary Rust interfaces.</p>
<h1 id="original-50" class="section-header"><a href="#original-50">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h1 id="api-differences-29" class="section-header"><a href="#api-differences-29">API Differences</a></h1>
<p>This returns a dedicated structure, rather than a range of <a href="../../bitvec/prelude/struct.BitPtr.html"><code>BitPtr</code></a>s,
because the traits needed for non-<code>core</code> types to correctly operate in
ranges are still unstable. The structure can be converted into a range,
but that range will not be an iterator.</p>
<h1 id="examples-79" class="section-header"><a href="#examples-79">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">mid_ptr</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">2</span>).<span class="ident">unwrap</span>().<span class="ident">into_bitptr</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">range</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_bitptr_range</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">range</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">mid_ptr</span>));
<span class="kw">unsafe</span> {
  <span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">range</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">read</span>());
  <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">range</span>.<span class="ident">next_back</span>().<span class="ident">unwrap</span>().<span class="ident">read</span>())
}</pre></div>
</div><h4 id="method.as_mut_bitptr_range" class="method"><code>pub fn <a href="#method.as_mut_bitptr_range" class="fnname">as_mut_bitptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../../bitvec/ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;M, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/prelude/struct.BitPtrRange.html" title="struct bitvec::prelude::BitPtrRange">BitPtrRange</a>&lt;M, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: Mutability,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = <a class="struct" href="../../bitvec/prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;M, O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#2300-2302" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the two unsafe mutable bit-pointers spanning the bit-slice.</p>
<p>The returned range is half-open, which means that the end bit-pointer
points <em>one past</em> the last bitt of the bit-slice. This way, an empty
bit-slice is represented by two equal bit-pointers, and the difference
between the two bit-pointers represents the size of the bit-slice.</p>
<p>See <a href="../../bitvec/slice/struct.BitSlice.html#method.as_mut_bitptr"><code>as_mut_bitptr</code></a> for warnings on using these bit-pointers. The end
bit-pointer requires extra caution, as it does not point to a valid bit
in the bit-slice.</p>
<h1 id="original-51" class="section-header"><a href="#original-51">Original</a></h1>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
<h1 id="api-differences-30" class="section-header"><a href="#api-differences-30">API Differences</a></h1>
<p>This returns a dedicated structure, rather than a range of <a href="../../bitvec/prelude/struct.BitPtr.html"><code>BitPtr</code></a>s,
because the traits needed for non-<code>core</code> types to correctly operate in
ranges are still unstable. The structure can be converted into a range,
but that range will not be an iterator.</p>
<h1 id="examples-80" class="section-header"><a href="#examples-80">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">ptr</span> <span class="kw">as</span> <span class="ident">bv_ptr</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">bitptr</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">as_mut_bitptr_range</span>() {
  <span class="kw">unsafe</span> { <span class="ident">bv_ptr</span>::<span class="ident">write</span>(<span class="ident">bitptr</span>, <span class="bool-val">true</span>); }
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="op">!</span><span class="number">0</span>);</pre></div>
</div><h4 id="method.bit_domain" class="method"><code>pub fn <a href="#method.bit_domain" class="fnname">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../../bitvec/domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2339-2341" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into subslices at alias boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../../bitvec/domain/enum.BitDomain.html"><code>BitDomain</code></a> splitting in its
documentation.</p>
<h1 id="examples-81" class="section-header"><a href="#examples-81">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">all</span>.<span class="ident">split_at_mut</span>(<span class="number">8</span>);
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">rest</span>[.. <span class="number">32</span>];

<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>
  .<span class="ident">bit_domain</span>()
  .<span class="ident">region</span>()
  .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">head</span>.<span class="ident">len</span>(), <span class="number">8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tail</span>.<span class="ident">len</span>(), <span class="number">8</span>);
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">head</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">tail</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">body</span>;</pre></div>
</div><h4 id="method.bit_domain_mut" class="method"><code>pub fn <a href="#method.bit_domain_mut" class="fnname">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../bitvec/domain/enum.BitDomainMut.html" title="enum bitvec::domain::BitDomainMut">BitDomainMut</a>&lt;'_, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2379-2381" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into subslices at alias boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../../bitvec/domain/enum.BitDomainMut.html"><code>BitDomainMut</code></a> splitting in its
documentation.</p>
<h1 id="examples-82" class="section-header"><a href="#examples-82">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">all</span>.<span class="ident">split_at_mut</span>(<span class="number">8</span>);
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span>
  <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">rest</span>[.. <span class="number">32</span>];

<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>
  .<span class="ident">bit_domain_mut</span>()
  .<span class="ident">region</span>()
  .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">head</span>.<span class="ident">len</span>(), <span class="number">8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tail</span>.<span class="ident">len</span>(), <span class="number">8</span>);
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">head</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">tail</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">body</span>;</pre></div>
</div><h4 id="method.domain" class="method"><code>pub fn <a href="#method.domain" class="fnname">domain</a>(&amp;self) -&gt; <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#2418-2420" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the underlying memory containing the slice, split at alias
boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locatinos that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../../bitvec/domain/enum.Domain.html"><code>Domain</code></a> splitting in its documentation.</p>
<h1 id="examples-83" class="section-header"><a href="#examples-83">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">all</span>.<span class="ident">split_at_mut</span>(<span class="number">8</span>);
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">rest</span>[.. <span class="number">32</span>];

<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>
  .<span class="ident">domain</span>()
  .<span class="ident">region</span>()
  .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">body</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span> <span class="op">=</span> <span class="ident">head</span>.<span class="ident">unwrap</span>().<span class="number">1</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span> <span class="op">=</span> <span class="ident">tail</span>.<span class="ident">unwrap</span>().<span class="number">0</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span>[<span class="ident">u16</span>] <span class="op">=</span> <span class="ident">body</span>;</pre></div>
</div><h4 id="method.domain_mut" class="method"><code>pub fn <a href="#method.domain_mut" class="fnname">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../bitvec/domain/enum.DomainMut.html" title="enum bitvec::domain::DomainMut">DomainMut</a>&lt;'_, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2459-2461" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the underlying memory containing the slice, split at alias
boundaries.</p>
<p>This splits <code>self</code> into the memory locations that it partially fills and
the memory locations that it completely fills. The locations that are
completely filled may be accessed without any <code>bitvec</code>-imposed alias
conditions, while the locations that are only partially filled are left
unchanged.</p>
<p>You can read more about the <a href="../../bitvec/domain/enum.DomainMut.html"><code>DomainMut</code></a> splitting in its
documentation.</p>
<h1 id="examples-84" class="section-header"><a href="#examples-84">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">all</span>.<span class="ident">split_at_mut</span>(<span class="number">8</span>);
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">rest</span>[.. <span class="number">32</span>];

<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>
  .<span class="ident">domain_mut</span>()
  .<span class="ident">region</span>()
  .<span class="ident">unwrap</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">body</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Access</span> <span class="op">=</span> <span class="ident">head</span>.<span class="ident">unwrap</span>().<span class="number">1</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u16</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Access</span> <span class="op">=</span> <span class="ident">tail</span>.<span class="ident">unwrap</span>().<span class="number">0</span>;
<span class="kw">let</span> <span class="kw">_</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u16</span>] <span class="op">=</span> <span class="ident">body</span>;</pre></div>
</div><h4 id="method.as_slice" class="method"><code>pub fn <a href="#method.as_slice" class="fnname">as_slice</a>(&amp;self) -&gt; &amp;[T]</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2472-2476" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the underlying memory containing the slice.</p>
<p>The returned slice handle views all elements touched by <code>self</code>, and
marks them all with <code>self</code>’s current aliasing state. For a more precise
view, or one that permits mutation, use <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>.domain()</code></a> or
<a href="../../bitvec/slice/struct.BitSlice.html#method.domain_mut"><code>.domain_mut()</code></a>.</p>
</div></div><div class="impl-items"><h4 id="method.split_at_aliased_mut" class="method"><code>pub fn <a href="#method.split_at_aliased_mut" class="fnname">split_at_aliased_mut</a>(&amp;mut self, mid: usize) -&gt; (&amp;mut Self, &amp;mut Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2578-2584" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits a mutable slice at some mid-point.</p>
<p>This method has the same behavior as <a href="../../bitvec/slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a>, except that it
does not apply an aliasing marker to the partitioned subslices.</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p>Because this method is defined only on <code>BitSlice</code>s whose <code>T</code> type is
alias-safe, the subslices do not need to be additionally marked.</p>
</div></div><div class="impl-items"><h4 id="associatedconstant.MAX_BITS" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_BITS" class="constant"><b>MAX_BITS</b></a>: usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2602" title="goto source code">[src]</a></h4><h4 id="associatedconstant.MAX_ELTS" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_ELTS" class="constant"><b>MAX_ELTS</b></a>: usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#2617" title="goto source code">[src]</a></h4></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#160-169" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#166-168" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#148-157" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_ref" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#154-156" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Binary" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Binary" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#252-261" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#258-260" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-BitAnd%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitAnd%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#25-38" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>&amp;</code> operator.</p>
</div><h4 id="method.bitand" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fnname">bitand</a>(self, rhs: Rhs) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#34-37" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>&amp;</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAnd.html#tymethod.bitand">Read more</a></p>
</div></div><h3 id="impl-BitAndAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitAndAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#40-50" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitand_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#47-49" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></p>
</div></div><h3 id="impl-BitField" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="../../bitvec/field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="../../bitvec/field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></code><a href="#impl-BitField" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#1346-1371" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1352-1355" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using little-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le">Read more</a></p>
</div><h4 id="method.load_be" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1357-1360" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using big-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be">Read more</a></p>
</div><h4 id="method.store_le" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1362-1365" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using little-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le">Read more</a></p>
</div><h4 id="method.store_be" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1367-1370" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using big-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be">Read more</a></p>
</div><h4 id="method.load" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#322-329" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads the bits in the <code>self</code> region into a local value. <a href="../../bitvec/field/trait.BitField.html#method.load">Read more</a></p>
</div><h4 id="method.store" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#372-379" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../../bitvec/field/trait.BitField.html#method.store">Read more</a></p>
</div></div><h3 id="impl-BitOr%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitOr%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#52-65" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>|</code> operator.</p>
</div><h4 id="method.bitor" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fnname">bitor</a>(self, rhs: Rhs) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#61-64" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>|</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOr.html#tymethod.bitor">Read more</a></p>
</div></div><h3 id="impl-BitOrAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitOrAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#67-77" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitor_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#74-76" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></p>
</div></div><h3 id="impl-BitXor%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitXor%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#79-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-3" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>^</code> operator.</p>
</div><h4 id="method.bitxor" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fnname">bitxor</a>(self, rhs: Rhs) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#88-91" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>^</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXor.html#tymethod.bitxor">Read more</a></p>
</div></div><h3 id="impl-BitXorAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-BitXorAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#94-104" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitxor_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#101-103" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#39-48" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#45-47" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#51-60" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#57-59" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-Clone" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#62-77" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#68-76" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#128" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id="impl-Copy" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><a href="#impl-Copy" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#382-387" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#263-274" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#269-273" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-Default" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Default" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#240-249" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.default" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#246-248" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id="impl-Deref" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Deref" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#107-118" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Target" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="type">Target</a> = <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code></h4><div class='docblock'><p>The resulting type after dereferencing.</p>
</div><h4 id="method.deref" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#115-117" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Dereferences the value.</p>
</div></div><h3 id="impl-DerefMut" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-DerefMut" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#121-130" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.deref_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#127-129" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences the value.</p>
</div></div><h3 id="impl-Display" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Display" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#277-286" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#283-285" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-Eq" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Eq" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#79-84" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-From%3CV%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;V&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-From%3CV%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#172-181" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(data: V) -&gt; Self</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#178-180" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Hash" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Hash" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#325-335" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.hash" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, hasher: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#331-334" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id="method.hash_slice" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#184-186" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id="impl-Index%3CIdx%3E" class="impl"><code class="in-band">impl&lt;O, V, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;,&nbsp;</span></code><a href="#impl-Index%3CIdx%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#132-144" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-4" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: Idx) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#141-143" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CIdx%3E" class="impl"><code class="in-band">impl&lt;O, V, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt;,&nbsp;</span></code><a href="#impl-IndexMut%3CIdx%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#146-156" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: Idx) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#153-155" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IntoIterator" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-IntoIterator" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#338-350" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.IntoIter" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../../bitvec/array/struct.IntoIter.html" title="struct bitvec::array::IntoIter">IntoIter</a>&lt;O, V&gt;</code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id="associatedtype.Item" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = bool</code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id="method.into_iter" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#347-349" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id="impl-IntoIterator-1" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-IntoIterator-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#353-365" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.IntoIter-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = &lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id="associatedtype.Item-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id="method.into_iter-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#362-364" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id="impl-IntoIterator-2" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-IntoIterator-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#368-380" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.IntoIter-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = &lt;&amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id="associatedtype.Item-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &lt;&amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id="method.into_iter-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#377-379" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id="impl-LowerHex" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-LowerHex" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#289-298" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#295-297" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-Not" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Not" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/ops.rs.html#158-172" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>!</code> operator.</p>
</div><h4 id="method.not" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></code><a class="srclink" href="../../src/bitvec/array/ops.rs.html#166-171" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></p>
</div></div><h3 id="impl-Octal" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Octal" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#301-310" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#307-309" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-Ord" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Ord" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#86-95" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.cmp" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#92-94" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div><h4 id="method.max" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#723-725" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div><h4 id="method.min" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#743-745" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div><h4 id="method.clamp" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#768-770" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></div><h3 id="impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E" class="impl"><code class="in-band">impl&lt;O, V, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#97-107" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#104-106" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-PartialEq%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#109-120" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#117-119" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E" class="impl"><code class="in-band">impl&lt;O, V, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#122-132" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#129-131" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, V, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt;,&nbsp;</span></code><a href="#impl-PartialOrd%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#134-145" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#142-144" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#183-199" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError&lt;'a, O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#191-198" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E-1" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for &amp;'a <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#201-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError&lt;'a, O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#209-217" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for &amp;'a mut <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#220-237" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError&lt;'a, O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#228-236" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#389-394" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-UpperHex" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,&nbsp;</span></code><a href="#impl-UpperHex" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#313-322" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#319-321" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../../src/bitvec/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../../src/bitvec/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-Conv" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.Conv.html" title="trait tap::conv::Conv">Conv</a> for T</code><a href="#impl-Conv" class="anchor"></a><a class="srclink" href="../../src/tap/conv.rs.html#58" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.conv" class="method hidden"><code>pub fn <a href="../../tap/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tap/conv.rs.html#49-52" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a href="../../tap/conv/trait.Conv.html#method.conv">Read more</a></p>
</div></div><h3 id="impl-Conv-1" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.Conv.html" title="trait wyz::conv::Conv">Conv</a> for T</code><a href="#impl-Conv-1" class="anchor"></a><a class="srclink" href="../../src/wyz/conv.rs.html#107-108" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.conv-1" class="method hidden"><code>pub fn <a href="../../wyz/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/wyz/conv.rs.html#101-102" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Converts <code>self</code> into a target type. <a href="../../wyz/conv/trait.Conv.html#method.conv">Read more</a></p>
</div></div><h3 id="impl-FmtForward" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</code><a href="#impl-FmtForward" class="anchor"></a><a class="srclink" href="../../src/wyz/fmt.rs.html#93-94" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt_binary" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fnname">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#39-40" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</p>
</div><h4 id="method.fmt_display" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fnname">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#46-47" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display">Read more</a></p>
</div><h4 id="method.fmt_lower_exp" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fnname">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#53-54" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp">Read more</a></p>
</div><h4 id="method.fmt_lower_hex" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fnname">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#60-61" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex">Read more</a></p>
</div><h4 id="method.fmt_octal" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fnname">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#66-67" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</p>
</div><h4 id="method.fmt_pointer" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fnname">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#73-74" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer">Read more</a></p>
</div><h4 id="method.fmt_upper_exp" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fnname">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#80-81" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp">Read more</a></p>
</div><h4 id="method.fmt_upper_hex" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fnname">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#87-88" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex">Read more</a></p>
</div></div><h3 id="impl-From%3C!%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;!&gt; for T</code><a href="#impl-From%3C!%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#560-564" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-2" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: !) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#561" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Pipe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../tap/pipe/trait.Pipe.html" title="trait tap::pipe::Pipe">Pipe</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Pipe" class="anchor"></a><a class="srclink" href="../../src/tap/pipe.rs.html#234" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</code><a class="srclink" href="../../src/tap/pipe.rs.html#73-76" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes by value. This is generally the method you want to use. <a href="../../tap/pipe/trait.Pipe.html#method.pipe">Read more</a></p>
</div><h4 id="method.pipe_ref" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#97-99" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref">Read more</a></p>
</div><h4 id="method.pipe_ref_mut" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut" class="fnname">pipe_ref_mut</a>&lt;'a, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#122-127" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut">Read more</a></p>
</div><h4 id="method.pipe_borrow" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a B) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#145-149" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow">Read more</a></p>
</div><h4 id="method.pipe_borrow_mut" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, B, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut B) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#169-176" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut">Read more</a></p>
</div><h4 id="method.pipe_as_ref" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a U) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#183-187" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</p>
</div><h4 id="method.pipe_as_mut" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, U, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut U) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#195-202" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut">Read more</a></p>
</div><h4 id="method.pipe_deref" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#209-213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</p>
</div><h4 id="method.pipe_deref_mut" class="method hidden"><code>pub fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/tap/pipe.rs.html#221-228" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut">Read more</a></p>
</div></div><h3 id="impl-Pipe-1" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.Pipe.html" title="trait wyz::pipe::Pipe">Pipe</a> for T</code><a href="#impl-Pipe-1" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#345-346" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</code><a class="srclink" href="../../src/wyz/pipe.rs.html#89-90" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a value into a function that cannot ordinarily be called in suffix
position. <a href="../../wyz/pipe/trait.Pipe.html#method.pipe">Read more</a></p>
</div></div><h3 id="impl-PipeAsRef" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeAsRef.html" title="trait wyz::pipe::PipeAsRef">PipeAsRef</a> for T</code><a href="#impl-PipeAsRef" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#354-355" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_as_ref-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#254-258" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref">Read more</a></p>
</div><h4 id="method.pipe_as_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#278-285" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut">Read more</a></p>
</div></div><h3 id="impl-PipeBorrow" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeBorrow.html" title="trait wyz::pipe::PipeBorrow">PipeBorrow</a> for T</code><a href="#impl-PipeBorrow" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#351-352" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_borrow-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#191-195" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow">Read more</a></p>
</div><h4 id="method.pipe_borrow_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#224-231" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut">Read more</a></p>
</div></div><h3 id="impl-PipeDeref" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeDeref.html" title="trait wyz::pipe::PipeDeref">PipeDeref</a> for T</code><a href="#impl-PipeDeref" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#357-358" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_deref-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#307-313" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a dereference into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref">Read more</a></p>
</div><h4 id="method.pipe_deref_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#333-339" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a mutable dereference into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut">Read more</a></p>
</div></div><h3 id="impl-PipeRef" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeRef.html" title="trait wyz::pipe::PipeRef">PipeRef</a> for T</code><a href="#impl-PipeRef" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#348-349" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_ref-1" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#130-131" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a reference into a function that cannot ordinarily be called in
suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref">Read more</a></p>
</div><h4 id="method.pipe_mut" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut" class="fnname">pipe_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#158-159" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a mutable reference into a function that cannot ordinarily be
called in suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut">Read more</a></p>
</div></div><h3 id="impl-Tap" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../tap/tap/trait.Tap.html" title="trait tap::tap::Tap">Tap</a> for T</code><a href="#impl-Tap" class="anchor"></a><a class="srclink" href="../../src/tap/tap.rs.html#329" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap" class="fnname">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self)) -&gt; Self</code><a class="srclink" href="../../src/tap/tap.rs.html#78" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap">Read more</a></p>
</div><h4 id="method.tap_mut" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self)) -&gt; Self</code><a class="srclink" href="../../src/tap/tap.rs.html#116" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap_mut">Read more</a></p>
</div><h4 id="method.tap_borrow" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#129-132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow">Read more</a></p>
</div><h4 id="method.tap_borrow_mut" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#146-149" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut">Read more</a></p>
</div><h4 id="method.tap_ref" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref" class="fnname">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#163-166" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref">Read more</a></p>
</div><h4 id="method.tap_ref_mut" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#180-183" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut">Read more</a></p>
</div><h4 id="method.tap_deref" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref" class="fnname">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#197-200" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref">Read more</a></p>
</div><h4 id="method.tap_deref_mut" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#214-217" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut">Read more</a></p>
</div><h4 id="method.tap_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self)) -&gt; Self</code><a class="srclink" href="../../src/tap/tap.rs.html#227" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</p>
</div><h4 id="method.tap_mut_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self)) -&gt; Self</code><a class="srclink" href="../../src/tap/tap.rs.html#237" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg">Read more</a></p>
</div><h4 id="method.tap_borrow_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#247-250" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg">Read more</a></p>
</div><h4 id="method.tap_borrow_mut_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#261-264" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg">Read more</a></p>
</div><h4 id="method.tap_ref_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#275-278" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg">Read more</a></p>
</div><h4 id="method.tap_ref_mut_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#289-292" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg">Read more</a></p>
</div><h4 id="method.tap_deref_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#303-306" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg">Read more</a></p>
</div><h4 id="method.tap_deref_mut_dbg" class="method hidden"><code>pub fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a class="srclink" href="../../src/tap/tap.rs.html#317-320" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg">Read more</a></p>
</div></div><h3 id="impl-Tap-1" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.Tap.html" title="trait wyz::tap::Tap">Tap</a> for T</code><a href="#impl-Tap-1" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#340-341" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap" class="fnname">tap</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#278-281" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access for inspection. <a href="../../wyz/tap/trait.Tap.html#method.tap">Read more</a></p>
</div><h4 id="method.tap_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#290-293" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#316-319" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access for modification. <a href="../../wyz/tap/trait.Tap.html#method.tap_mut">Read more</a></p>
</div><h4 id="method.tap_mut_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#328-331" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_mut</code> in debug builds, and does nothing in release builds.</p>
</div></div><h3 id="impl-TapAsRef%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapAsRef.html" title="trait wyz::tap::TapAsRef">TapAsRef</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TapAsRef%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#560-561" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_ref-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref" class="fnname">tap_ref</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#512-515" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access to the reference for inspection.</p>
</div><h4 id="method.tap_ref_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#524-527" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_ref</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_ref_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#536-539" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access to the reference for modification.</p>
</div><h4 id="method.tap_ref_mut_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#548-551" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_ref_mut</code> in debug builds, and does nothing in release builds.</p>
</div></div><h3 id="impl-TapBorrow%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapBorrow.html" title="trait wyz::tap::TapBorrow">TapBorrow</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TapBorrow%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#438-439" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_borrow-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#385-389" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access to the borrow for inspection. <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow">Read more</a></p>
</div><h4 id="method.tap_borrow_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#398-402" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_borrow</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_borrow_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#411-415" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access to the borrow for modification.</p>
</div><h4 id="method.tap_borrow_mut_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#425-429" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_borrow_mut</code> in debug builds, and does nothing in release
builds. <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut_dbg">Read more</a></p>
</div></div><h3 id="impl-TapDeref" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.TapDeref.html" title="trait wyz::tap::TapDeref">TapDeref</a> for T</code><a href="#impl-TapDeref" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#636-637" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_deref-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref" class="fnname">tap_deref</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#589-592" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably dereferences <code>self</code> for inspection.</p>
</div><h4 id="method.tap_deref_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#600-603" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_deref</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_deref_mut-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#612-615" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences <code>self</code> for modification.</p>
</div><h4 id="method.tap_deref_mut_dbg-1" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#624-627" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_deref_mut</code> in debug builds, and does nothing in release
builds. <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut_dbg">Read more</a></p>
</div></div><h3 id="impl-TryConv" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.TryConv.html" title="trait tap::conv::TryConv">TryConv</a> for T</code><a href="#impl-TryConv" class="anchor"></a><a class="srclink" href="../../src/tap/conv.rs.html#87" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.try_conv" class="method hidden"><code>pub fn <a href="../../tap/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/tap/conv.rs.html#78-81" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a href="../../tap/conv/trait.TryConv.html#method.try_conv">Read more</a></p>
</div></div><h3 id="impl-TryConv-1" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.TryConv.html" title="trait wyz::conv::TryConv">TryConv</a> for T</code><a href="#impl-TryConv-1" class="anchor"></a><a class="srclink" href="../../src/wyz/conv.rs.html#209-210" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.try_conv-1" class="method hidden"><code>pub fn <a href="../../wyz/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/wyz/conv.rs.html#203-204" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Attempts to convert <code>self</code> into a target type. <a href="../../wyz/conv/trait.TryConv.html#method.try_conv">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-3" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-3" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-4" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>