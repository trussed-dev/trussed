<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `BitSlice` struct in crate `bitvec`."><meta name="keywords" content="rust, rustlang, rust-lang, BitSlice"><title>bitvec::slice::BitSlice - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct BitSlice</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.align_to">align_to</a><a href="#method.align_to_mut">align_to_mut</a><a href="#method.all">all</a><a href="#method.any">any</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_raw_slice">as_raw_slice</a><a href="#method.as_raw_slice_mut">as_raw_slice_mut</a><a href="#method.as_slice">as_slice</a><a href="#method.bit_domain">bit_domain</a><a href="#method.bit_domain_mut">bit_domain_mut</a><a href="#method.chunks">chunks</a><a href="#method.chunks_exact">chunks_exact</a><a href="#method.chunks_exact_mut">chunks_exact_mut</a><a href="#method.chunks_mut">chunks_mut</a><a href="#method.clone_from_bitslice">clone_from_bitslice</a><a href="#method.contains">contains</a><a href="#method.copy_from_bitslice">copy_from_bitslice</a><a href="#method.copy_unchecked">copy_unchecked</a><a href="#method.copy_within">copy_within</a><a href="#method.copy_within_unchecked">copy_within_unchecked</a><a href="#method.count_ones">count_ones</a><a href="#method.count_zeros">count_zeros</a><a href="#method.domain">domain</a><a href="#method.domain_mut">domain_mut</a><a href="#method.empty">empty</a><a href="#method.empty_mut">empty_mut</a><a href="#method.ends_with">ends_with</a><a href="#method.first">first</a><a href="#method.first_mut">first_mut</a><a href="#method.for_each">for_each</a><a href="#method.from_element">from_element</a><a href="#method.from_element_mut">from_element_mut</a><a href="#method.from_slice">from_slice</a><a href="#method.from_slice_mut">from_slice_mut</a><a href="#method.from_slice_unchecked">from_slice_unchecked</a><a href="#method.from_slice_unchecked_mut">from_slice_unchecked_mut</a><a href="#method.get">get</a><a href="#method.get_mut">get_mut</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.is_empty">is_empty</a><a href="#method.iter">iter</a><a href="#method.iter_mut">iter_mut</a><a href="#method.last">last</a><a href="#method.last_mut">last_mut</a><a href="#method.len">len</a><a href="#method.not_all">not_all</a><a href="#method.not_any">not_any</a><a href="#method.rchunks">rchunks</a><a href="#method.rchunks_exact">rchunks_exact</a><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a><a href="#method.rchunks_mut">rchunks_mut</a><a href="#method.reverse">reverse</a><a href="#method.rotate_left">rotate_left</a><a href="#method.rotate_right">rotate_right</a><a href="#method.rsplit">rsplit</a><a href="#method.rsplit_mut">rsplit_mut</a><a href="#method.rsplitn">rsplitn</a><a href="#method.rsplitn_mut">rsplitn_mut</a><a href="#method.set">set</a><a href="#method.set_all">set_all</a><a href="#method.set_unchecked">set_unchecked</a><a href="#method.some">some</a><a href="#method.split">split</a><a href="#method.split_at">split_at</a><a href="#method.split_at_aliased_mut">split_at_aliased_mut</a><a href="#method.split_at_aliased_unchecked_mut">split_at_aliased_unchecked_mut</a><a href="#method.split_at_mut">split_at_mut</a><a href="#method.split_at_unchecked">split_at_unchecked</a><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a><a href="#method.split_first">split_first</a><a href="#method.split_first_mut">split_first_mut</a><a href="#method.split_last">split_last</a><a href="#method.split_last_mut">split_last_mut</a><a href="#method.split_mut">split_mut</a><a href="#method.splitn">splitn</a><a href="#method.splitn_mut">splitn_mut</a><a href="#method.starts_with">starts_with</a><a href="#method.swap">swap</a><a href="#method.swap_unchecked">swap_unchecked</a><a href="#method.swap_with_bitslice">swap_with_bitslice</a><a href="#method.windows">windows</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">AsMut&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">AsRef&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E">AsRef&lt;BitSlice&lt;O, T&gt;&gt;</a><a href="#impl-Binary">Binary</a><a href="#impl-BitAndAssign%3CRhs%3E">BitAndAssign&lt;Rhs&gt;</a><a href="#impl-BitField">BitField</a><a href="#impl-BitOrAssign%3CRhs%3E">BitOrAssign&lt;Rhs&gt;</a><a href="#impl-BitXorAssign%3CRhs%3E">BitXorAssign&lt;Rhs&gt;</a><a href="#impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">Borrow&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">BorrowMut&lt;BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Display">Display</a><a href="#impl-Eq">Eq</a><a href="#impl-Hash">Hash</a><a href="#impl-Index%3CRange%3Cusize%3E%3E">Index&lt;Range&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E">Index&lt;RangeFrom&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeFull%3E">Index&lt;RangeFull&gt;</a><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E">Index&lt;RangeInclusive&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E">Index&lt;RangeTo&lt;usize&gt;&gt;</a><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E">Index&lt;RangeToInclusive&lt;usize&gt;&gt;</a><a href="#impl-Index%3Cusize%3E">Index&lt;usize&gt;</a><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E">IndexMut&lt;Range&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E">IndexMut&lt;RangeFrom&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeFull%3E">IndexMut&lt;RangeFull&gt;</a><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E">IndexMut&lt;RangeInclusive&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E">IndexMut&lt;RangeTo&lt;usize&gt;&gt;</a><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E">IndexMut&lt;RangeToInclusive&lt;usize&gt;&gt;</a><a href="#impl-IntoIterator">IntoIterator</a><a href="#impl-LowerHex">LowerHex</a><a href="#impl-Not">Not</a><a href="#impl-Octal">Octal</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E">PartialEq&lt;&amp;&#39;_ BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-PartialEq%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E">PartialEq&lt;&amp;&#39;_ mut BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E">PartialEq&lt;BitArray&lt;O, V&gt;&gt;</a><a href="#impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E">PartialEq&lt;BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E">PartialOrd&lt;&amp;&#39;_ BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-PartialOrd%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E">PartialOrd&lt;&amp;&#39;_ mut BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E">PartialOrd&lt;BitArray&lt;O, V&gt;&gt;</a><a href="#impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E">PartialOrd&lt;BitSlice&lt;O2, T2&gt;&gt;</a><a href="#impl-Pointer">Pointer</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-TryFrom%3C%26%27_%20BitSlice%3CO2%2C%20T%3E%3E">TryFrom&lt;&amp;&#39;_ BitSlice&lt;O2, T&gt;&gt;</a><a href="#impl-TryFrom%3C%26%27a%20%5BT%5D%3E">TryFrom&lt;&amp;&#39;a [T]&gt;</a><a href="#impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">TryFrom&lt;&amp;&#39;a BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E">TryFrom&lt;&amp;&#39;a mut BitSlice&lt;O, &lt;V as BitView&gt;::Store&gt;&gt;</a><a href="#impl-UpperHex">UpperHex</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-Unpin">Unpin</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-Conv">Conv</a><a href="#impl-FmtForward">FmtForward</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pipe">Pipe</a><a href="#impl-PipeAsRef">PipeAsRef</a><a href="#impl-PipeBorrow">PipeBorrow</a><a href="#impl-PipeDeref">PipeDeref</a><a href="#impl-PipeRef">PipeRef</a><a href="#impl-Tap">Tap</a><a href="#impl-TapAsRef%3CU%3E">TapAsRef&lt;U&gt;</a><a href="#impl-TapBorrow%3CU%3E">TapBorrow&lt;U&gt;</a><a href="#impl-TapDeref">TapDeref</a><a href="#impl-TryConv">TryConv</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="../index.html">bitvec</a>::<wbr><a href="index.html">slice</a></p><div id="sidebar-vars" data-name="BitSlice" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">slice</a>::<wbr><a class="struct" href="">BitSlice</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/bitvec/slice.rs.html#382-412" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust struct"><span class="docblock attributes top-attr">#[repr(transparent)]</span>pub struct BitSlice&lt;O&nbsp;=&nbsp;<a class="struct" href="../../bitvec/order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, T&nbsp;=&nbsp;usize&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span> { /* fields omitted */ }</pre></div><div class="docblock"><p>A slice of individual bits, anywhere in memory.</p>
<p>This is the main working type of the crate. It is analagous to <code>[bool]</code>, and is
written to be as close as possible to drop-in replacable for it. This type
contains most of the <em>methods</em> used to operate on memory, but it will rarely be
named directly in your code. You should generally prefer to use <a href="../array/struct.BitArray.html"><code>BitArray</code></a> for
fixed-size arrays or <a href="../vec/struct.BitVec.html"><code>BitVec</code></a> for dynamic vectors, and use <code>&amp;BitSlice</code>
references only where you would directly use <code>&amp;[bool]</code> or <code>&amp;[u8]</code> references
before using this crate.</p>
<p>As it is a slice wrapper, you are intended to work with this through references
(<code>&amp;BitSlice&lt;O, T&gt;</code> and <code>&amp;mut BitSlice&lt;O, T&gt;</code>) or through the other data
structures provided by <code>bitvec</code> that are implemented atop it. Once created,
references to <code>BitSlice</code> are guaranteed to work just like references to <code>[bool]</code>
to the fullest extent possible in the Rust language.</p>
<p>Every bit-vector crate can give you an opaque type that hides shift/mask
operations from you. <code>BitSlice</code> does far more than this: it offers you the full
Rust guarantees about reference behavior, including lifetime tracking,
mutability and aliasing awareness, and explicit memory control, <em>as well as</em> the
full set of tools and APIs available to the standard <code>[bool]</code> slice type.
<code>BitSlice</code> can arbitrarily split and subslice, just like <code>[bool]</code>. You can write
a linear consuming function and keep the patterns already know.</p>
<p>For example, to trim all the bits off either edge that match a condition, you
could write</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">trim</span><span class="op">&lt;</span><span class="ident">O</span>: <span class="ident">BitOrder</span>, <span class="ident">T</span>: <span class="ident">BitStore</span><span class="op">&gt;</span>(
  <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>,
  <span class="ident">to_trim</span>: <span class="ident">bool</span>,
) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
  <span class="kw">let</span> <span class="ident">stop</span> <span class="op">=</span> <span class="op">|</span><span class="ident">b</span>: <span class="kw-2">&amp;</span><span class="ident">bool</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">b</span> <span class="op">!</span><span class="op">=</span> <span class="ident">to_trim</span>;
  <span class="kw">let</span> <span class="ident">front</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>().<span class="ident">position</span>(<span class="ident">stop</span>).<span class="ident">unwrap_or</span>(<span class="number">0</span>);
  <span class="kw">let</span> <span class="ident">back</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>().<span class="ident">rposition</span>(<span class="ident">stop</span>).<span class="ident">unwrap_or</span>(<span class="number">0</span>);
  <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="ident">front</span> ..<span class="op">=</span> <span class="ident">back</span>]
}</pre></div>
<p>to get behavior something like
<code>trim(&amp;BitSlice[0, 0, 1, 1, 0, 1, 0], false) == &amp;BitSlice[1, 1, 0, 1]</code>.</p>
<h1 id="documentation" class="section-header"><a href="#documentation">Documentation</a></h1>
<p>All APIs that mirror something in the standard library will have an <code>Original</code>
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an <code>API Differences</code> section
explaining what has changed, and how to adapt your existing code to the change.</p>
<p>These sections look like this:</p>
<h1 id="original" class="section-header"><a href="#original">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>slice</code></a></p>
<h1 id="api-differences" class="section-header"><a href="#api-differences">API Differences</a></h1>
<p>The slice type <code>[bool]</code> has no type parameters. <code>BitSlice&lt;O, T&gt;</code> has two: one
for the memory type used as backing storage, and one for the order of bits
within that memory type.</p>
<p><code>&amp;BitSlice&lt;O, T&gt;</code> is capable of producing <code>&amp;bool</code> references to read bits out
of its memory, but is not capable of producing <code>&amp;mut bool</code> references to write
bits <em>into</em> its memory. Any <code>[bool]</code> API that would produce a <code>&amp;mut bool</code> will
instead produce a <a href="struct.BitMut.html"><code>BitMut&lt;O, T&gt;</code></a> proxy reference.</p>
<h1 id="behavior" class="section-header"><a href="#behavior">Behavior</a></h1>
<p><code>BitSlice</code> is a wrapper over <code>[T]</code>. It describes a region of memory, and must be
handled indirectly. This is most commonly through the reference types
<code>&amp;BitSlice</code> and <code>&amp;mut BitSlice</code>, which borrow memory owned by some other value
in the program. These buffers can be directly owned by the sibling types
<code>BitBox</code>, which behavios like <code>Box&lt;[T]&gt;</code>, and <code>BitVec</code>, which behaves like
<code>Vec&lt;T&gt;</code>. It cannot be used as the type parameter to a standard-library-provided
handle type.</p>
<p>The <code>BitSlice</code> region provides access to each individual bit in the region, as
if each bit had a memory address that you could use to dereference it. It packs
each logical bit into exactly one bit of storage memory, just like
<a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a> and <a href="https://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a> in C++.</p>
<h1 id="type-parameters" class="section-header"><a href="#type-parameters">Type Parameters</a></h1>
<p><code>BitSlice</code> has two type parameters which propagate through nearly every public
API in the crate. These are very important to its operation, and your choice
of type arguments informs nearly every part of this library’s behavior.</p>
<h2 id="t-bitstore" class="section-header"><a href="#t-bitstore"><code>T: BitStore</code></a></h2>
<p>This is the simpler of the two parameters. It refers to the integer type used to
hold bits. It must be one of the Rust unsigned integer fundamentals: <code>u8</code>,
<code>u16</code>, <code>u32</code>, <code>usize</code>, and on 64-bit systems only, <code>u64</code>. In addition, it can
also be the <code>Cell&lt;N&gt;</code> wrapper over any of those, or their equivalent types in
<code>core::sync::atomic</code>. Unless you know you need to have <code>Cell</code> or atomic
properties, though, you should use a plain integer.</p>
<p>The default type argument is <code>usize</code>.</p>
<p>The argument you choose is used as the basis of a <code>[T]</code> slice, over which the
<code>BitSlice</code> view type is placed. <code>BitSlice&lt;_, T&gt;</code> is subject to all of the rules
about alignment that <code>[T]</code> is. If you are working with in-memory representation
formats, chances are that you already have a <code>T</code> type with which you’ve been
working, and should use it here.</p>
<p>If you are only using this crate to discard the seven wasted bits per <code>bool</code>
of a collection of <code>bool</code>s, and are not too concerned about the in-memory
representation, then you should use the default type argument of <code>usize</code>. This
is because most processors work best when moving an entire <code>usize</code> between
memory and the processor itself, and using a smaller type may cause it to slow
down.</p>
<h2 id="o-bitorder" class="section-header"><a href="#o-bitorder"><code>O: BitOrder</code></a></h2>
<p>This is the more complex parameter. It has a default argument which, like
<code>usize</code>, is the good-enough choice when you do not explicitly need to control
the representation of bits in memory.</p>
<p>This parameter determines how to index the bits within a single memory element
<code>T</code>. Computers all agree that in a slice of elements <code>T</code>, the element with the
lower index has a lower memory address than the element with the higher index.
But the individual bits within an element do not have addresses, and so there is
no uniform standard of which bit is the zeroth, which is the first, which is the
penultimate, and which is the last.</p>
<p>To make matters even more confusing, there are two predominant ideas of
in-element ordering that often <em>correlate</em> with the in-element <em>byte</em> ordering
of integer types, but are in fact wholly unrelated! <code>bitvec</code> provides these two
main orders as types for you, and if you need a different one, it also provides
the tools you need to make your own.</p>
<h3 id="least-significant-bit-comes-first" class="section-header"><a href="#least-significant-bit-comes-first">Least Significant Bit Comes First</a></h3>
<p>This ordering, named the <a href="../order/struct.Lsb0.html"><code>Lsb0</code></a> type, indexes bits within an element by
placing the <code>0</code> index at the least significant bit (numeric value <code>1</code>) and the
final index at the most significant bit (numeric value <code>T::min_value()</code>, for
signed integers on most machines).</p>
<p>For example, this is the ordering used by the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">TCP wire format</a>, and by most C
compilers to lay out bit-field struct members on little-endian <strong>byte</strong>-ordered
machines.</p>
<h3 id="most-significant-bit-comes-first" class="section-header"><a href="#most-significant-bit-comes-first">Most Significant Bit Comes First</a></h3>
<p>This ordering, named the <a href="../order/struct.Msb0.html"><code>Msb0</code></a> type, indexes bits within an element by
placing the <code>0</code> index at the most significant bit (numeric value <code>T::min_value()</code>
for most signed integers) and the final index at the least significant bit
(numeric value <code>1</code>).</p>
<p>This is the ordering used by most C compilers to lay out bit-field struct
members on big-endian <strong>byte</strong>-ordered machines.</p>
<h3 id="default-ordering" class="section-header"><a href="#default-ordering">Default Ordering</a></h3>
<p>The default ordering is <code>Lsb0</code>, as it typically produces shorter object code
than <code>Msb0</code> does. If you are implementing a collection, then <code>Lsb0</code> is likely
the more performant ordering; if you are implementing a buffer protocol, then
your choice of ordering is dictated by the protocol definition.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p><code>BitSlice</code> is designed to never introduce new memory unsafety that you did not
provide yourself, either before or during the use of this crate. Bugs do, and
have, occured, and you are encouraged to submit any discovered flaw as a defect
report.</p>
<p>The <code>&amp;BitSlice</code> reference type uses a private encoding scheme to hold all the
information needed in its stack value. This encoding is <strong>not</strong> part of the
public API of the library, and is not binary-compatible with <code>&amp;[T]</code>.
Furthermore, in order to satisfy Rust’s requirements about alias conditions,
<code>BitSlice</code> performs type transformations on the <code>T</code> parameter to ensure that it
never creates the potential for undefined behavior.</p>
<p>You must never attempt to type-cast a reference to <code>BitSlice</code> in any way. You
must not use <code>mem::transmute</code> with <code>BitSlice</code> anywhere in its type arguments.
You must not use <code>as</code>-casting to convert between <code>*BitSlice</code> and any other type.
You must not attempt to modify the binary representation of a <code>&amp;BitSlice</code>
reference value. These actions will all lead to runtime memory unsafety, are
(hopefully) likely to induce a program crash, and may possibly cause undefined
behavior at compile-time.</p>
<p>Everything in the <code>BitSlice</code> public API, even the <code>unsafe</code> parts, are guaranteed
to have no more unsafety than their equivalent parts in the standard library.
All <code>unsafe</code> APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.</p>
<h1 id="performance" class="section-header"><a href="#performance">Performance</a></h1>
<p>Like the standard library’s <code>[T]</code> slice, <code>BitSlice</code> is designed to be very easy
to use safely, while supporting <code>unsafe</code> when necessary. Rust has a powerful
optimizing engine, and <code>BitSlice</code> will frequently be compiled to have zero
runtime cost. Where it is slower, it will not be significantly slower than a
manual replacement.</p>
<p>As the machine instructions operate on registers rather than bits, your choice
of <code>T: BitOrder</code> type parameter can influence your slice’s performance. Using
larger register types means that slices can gallop over completely-filled
interior elements faster, while narrower register types permit more graceful
handling of subslicing and aliased splits.</p>
<h1 id="construction" class="section-header"><a href="#construction">Construction</a></h1>
<p><code>BitSlice</code> views of memory can be constructed over borrowed data in a number of
ways. As this is a reference-only type, it can only ever be built by borrowing
an existing memory buffer and taking temporary control of your program’s view of
the region.</p>
<h2 id="macro-constructor" class="section-header"><a href="#macro-constructor">Macro Constructor</a></h2>
<p><code>BitSlice</code> buffers can be constructed at compile-time through the <a href="../macro.bits.html"><code>bits!</code></a>
macro. This macro accepts a superset of the <code>vec!</code> arguments, and creates an
appropriate buffer in your program’s static memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">static_borrow</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">mutable_static</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">8</span>];

<span class="macro">assert_ne</span><span class="macro">!</span>(<span class="ident">static_borrow</span>, <span class="ident">mutable_static</span>);
<span class="ident">mutable_static</span>.<span class="ident">clone_from_bitslice</span>(<span class="ident">static_borrow</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">static_borrow</span>, <span class="ident">mutable_static</span>);</pre></div>
<p>Note that, despite constructing a <code>static mut</code> binding, the <code>bits![mut …]</code> call
is not <code>unsafe</code>, as the constructed symbol is hidden and only accessible by the
sole <code>&amp;mut</code> reference returned by the macro call.</p>
<h2 id="borrowing-constructors" class="section-header"><a href="#borrowing-constructors">Borrowing Constructors</a></h2>
<p>The functions [<code>from_element</code>], [<code>from_element_mut</code>], [<code>from_slice</code>], and
[<code>from_slice_mut</code>] take references to existing memory, and construct <code>BitSlice</code>
references over them. These are the most basic ways to borrow memory and view it
as bits.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u16</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">local_borrow</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">local_mut</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_slice_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>);</pre></div>
<h2 id="trait-method-constructors" class="section-header"><a href="#trait-method-constructors">Trait Method Constructors</a></h2>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait implements <code>.view_bits::&lt;O&gt;()</code> and <code>.view_bits_mut::&lt;O&gt;()</code>
methods on elements, arrays not larger than 32 elements, and slices. This trait,
imported in the crate prelude, is <em>probably</em> the easiest way for you to borrow
memory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u32</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">trait_view</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0usize</span>;
<span class="kw">let</span> <span class="ident">trait_mut</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();</pre></div>
<h2 id="owned-bit-slices" class="section-header"><a href="#owned-bit-slices">Owned Bit Slices</a></h2>
<p>If you wish to take ownership of a memory region and enforce that it is always
viewed as a <code>BitSlice</code> by default, you can use one of the <a href="../array/struct.BitArray.html"><code>BitArray</code></a>,
<a href="../boxed/struct.BitBox.html"><code>BitBox</code></a>, or <a href="../vec/struct.BitVec.html"><code>BitVec</code></a> types, rather than pairing ordinary buffer types with
the borrowing constructors.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">27</span>];
<span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">LocalBits</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let</span> <span class="ident">boxed</span> <span class="op">=</span> <span class="macro">bitbox</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">bitvec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">20</span>];

<span class="comment">// arrays always round up</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">array</span>.<span class="ident">as_bitslice</span>(), <span class="ident">slice</span>[.. <span class="number">16</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">boxed</span>.<span class="ident">as_bitslice</span>(), <span class="ident">slice</span>[.. <span class="number">10</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">as_bitslice</span>(), <span class="ident">slice</span>[.. <span class="number">20</span>]);</pre></div>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/api.rs.html#59-2242" title="goto source code">[src]</a></h3><div class="docblock"><p>Port of the <code>[T]</code> inherent API.</p>
</div><div class="impl-items"><h4 id="method.len" class="method"><code>pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#80-82" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of bits in the slice.</p>
<h1 id="original-1" class="section-header"><a href="#original-1">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u32</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">32</span>);</pre></div>
</div><h4 id="method.is_empty" class="method"><code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#99-108" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h1 id="original-2" class="section-header"><a href="#original-2">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">u8</span><span class="op">&gt;</span>::<span class="ident">empty</span>().<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span>(<span class="number">0u32</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>()).<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.first" class="method"><code>pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;bool&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#129-131" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first bit of the slice, or <code>None</code> if it is empty.</p>
<h1 id="original-3" class="section-header"><a href="#original-3">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">bits</span>.<span class="ident">first</span>());

<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">empty</span>.<span class="ident">first</span>());</pre></div>
</div><h4 id="method.first_mut" class="method"><code>pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#161-163" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable pointer to the first bit of the slice, or <code>None</code> if it
is empty.</p>
<h1 id="original-4" class="section-header"><a href="#original-4">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h1 id="api-differences-1" class="section-header"><a href="#api-differences-1">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">first</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">1</span>);</pre></div>
</div><h4 id="method.split_first" class="method"><code>pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;bool, &amp;Self)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#184-192" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h1 id="original-5" class="section-header"><a href="#original-5">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#split_first"><code>slice::split_first</code></a></p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first</span>() {
  <span class="macro">assert</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">first</span>);
}</pre></div>
</div><h4 id="method.split_first_mut" class="method"><code>pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#232-242" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h1 id="original-6" class="section-header"><a href="#original-6">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#split_first_mut"><code>slice::split_first_mut</code></a></p>
<h1 id="api-differences-2" class="section-header"><a href="#api-differences-2">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0usize</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">get_mut</span>(<span class="number">1</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">5</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty_mut</span>().<span class="ident">split_first_mut</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.split_last" class="method"><code>pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;bool, &amp;Self)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#264-272" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h1 id="original-7" class="section-header"><a href="#original-7">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last</span>() {
  <span class="macro">assert</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">last</span>);
}</pre></div>
</div><h4 id="method.split_last_mut" class="method"><code>pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../../bitvec/slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#312-322" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h1 id="original-8" class="section-header"><a href="#original-8">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h1 id="api-differences-3" class="section-header"><a href="#api-differences-3">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<p>Because the references are permitted to use the same memory address,
they are marked as aliasing in order to satisfy Rust’s requirements
about freedom from data races.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">get_mut</span>(<span class="number">5</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">5</span>);

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty_mut</span>().<span class="ident">split_last_mut</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.last" class="method"><code>pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;bool&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#343-348" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the last bit of the slice, or <code>None</code> if it is empty.</p>
<h1 id="original-9" class="section-header"><a href="#original-9">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">bits</span>.<span class="ident">last</span>());

<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">empty</span>.<span class="ident">last</span>());</pre></div>
</div><h4 id="method.last_mut" class="method"><code>pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#378-383" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable pointer to the last bit of the slice, or <code>None</code> if it
is empty.</p>
<h1 id="original-10" class="section-header"><a href="#original-10">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h1 id="api-differences-4" class="section-header"><a href="#api-differences-4">API Differences</a></h1>
<p>This crate cannot manifest <code>&amp;mut bool</code> references, and must use the
<code>BitMut</code> proxy type where <code>&amp;mut bool</code> exists in the standard library
API. The proxy value must be bound as <code>mut</code> in order to write through
it.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">last</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">1</span>);</pre></div>
</div><h4 id="method.get" class="method"><code>pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#411-414" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to an element or subslice depending on the type of
index.</p>
<ul>
<li>If given a position, returns a reference to the element at that
position or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range, or
<code>None</code> if out of bounds.</li>
</ul>
<h1 id="original-11" class="section-header"><a href="#original-11">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">2u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">3</span>]), <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span> .. <span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">8</span> .. <span class="number">10</span>));</pre></div>
</div><h4 id="method.get_mut" class="method"><code>pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#442-445" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable reference to an element or subslice depending on the
type of index (see <a href="#method.get"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h1 id="original-12" class="section-header"><a href="#original-12">Original</a></h1>
<p><a href="https://doc.rust-lang.org/core/slice/trait.SliceIndex.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h1 id="api-differences-5" class="section-header"><a href="#api-differences-5">API Differences</a></h1>
<p>When <code>I</code> is <code>usize</code>, this returns <code>BitMut</code> instead of <code>&amp;mut bool</code>.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">unwrap</span>());
<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">1</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">unwrap</span>());</pre></div>
</div><h4 id="method.get_unchecked" class="method"><code>pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#480-483" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a reference to an element or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended; use with caution!</p>
<p>Unlike the original slice function, calling this with an out-of-bounds
index is not <em>technically</em> compile-time <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>, as the
references produced do not actually describe local memory. However, the
use of an out-of-bounds index will eventually cause an out-of-bounds
memory read, which is a runtime safety violation. For a safe alternative
see <a href="#method.get"><code>get</code></a>.</p>
<h1 id="original-13" class="section-header"><a href="#original-13">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">2u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span>{
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>), <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
}</pre></div>
</div><h4 id="method.get_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#520-523" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a mutable reference to the output at this location, without
doing bounds checking.</p>
<p>This is generally not recommended; use with caution!</p>
<p>Unlike the original slice function, calling this with an out-of-bounds
index is not <em>technically</em> compile-time <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>, as the
references produced do not actually describe local memory. However, the
use of an out-of-bounds index will eventually cause an out-of-bounds
memory write, which is a runtime safety violation. For a safe
alternative see <a href="#method.get_mut"><code>get_mut</code></a>.</p>
<h1 id="original-14" class="section-header"><a href="#original-14">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>);
  <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">2</span>);</pre></div>
</div><h4 id="method.as_ptr" class="method"><code>pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; *const Self</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#578-580" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns a raw bit-slice pointer to the region.</p>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the pointer
(non-transitively) points to is only written to if <code>T</code> allows shared
mutation, using this pointer or any pointer derived from it. If you need
to mutate the contents of the slice, use <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<p>Modifying the container (such as <code>BitVec</code>) referenced by this slice may
cause its buffer to be reällocated, which would also make any pointers
to it invalid.</p>
<h1 id="original-15" class="section-header"><a href="#original-15">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h1 id="api-differences-6" class="section-header"><a href="#api-differences-6">API Differences</a></h1>
<p>This returns <code>*const BitSlice</code>, which is the equivalent of <code>*const [T]</code>
instead of <code>*const T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h1 id="notes" class="section-header"><a href="#notes">Notes</a></h1>
<p>You <strong>cannot</strong> use any of the methods in the <code>pointer</code> fundamental type
or the <code>core::ptr</code> module on the <code>*_ BitSlice</code> type. This pointer
retains the <code>bitvec</code>-specific value encoding, and is incomprehensible by
the Rust standard library.</p>
<p>The only thing you can do with this pointer is dereference it.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">2u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_ptr</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_ptr</span>();

<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">bits</span>.<span class="ident">len</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="ident">i</span>], <span class="kw">unsafe</span> {
    (<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">bits_ptr</span>)[<span class="ident">i</span>]
  });
}</pre></div>
</div><h4 id="method.as_mut_ptr" class="method"><code>pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; *mut Self</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#625-627" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an unsafe mutable bit-slice pointer to the region.</p>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container (such as <code>BitVec</code>) referenced by this slice may
cause its buffer to be reällocated, which would also make any pointers
to it invalid.</p>
<h1 id="original-16" class="section-header"><a href="#original-16">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h1 id="api-differences-7" class="section-header"><a href="#api-differences-7">API Differences</a></h1>
<p>This returns <code>*mut BitSlice</code>, which is the equivalont of <code>*mut [T]</code>
instead of <code>*mut T</code>. The pointer encoding used requires more than one
CPU word of space to address a single bit, so there is no advantage to
removing the length information from the encoded pointer value.</p>
<h1 id="notes-1" class="section-header"><a href="#notes-1">Notes</a></h1>
<p>You <strong>cannot</strong> use any of the methods in the <code>pointer</code> fundamental type
or the <code>core::ptr</code> module on the <code>*_ BitSlice</code> type. This pointer
retains the <code>bitvec</code>-specific value encoding, and is incomprehensible by
the Rust standard library.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_ptr</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">bits</span>.<span class="ident">len</span>() {
  <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">bits_ptr</span> }.<span class="ident">set</span>(<span class="ident">i</span>, <span class="ident">i</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b0101_0101_0101_0101</span>);</pre></div>
</div><h4 id="method.swap" class="method"><code>pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: usize, b: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#655-662" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps two bits in the slice.</p>
<h1 id="original-17" class="section-header"><a href="#original-17">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h1 id="arguments" class="section-header"><a href="#arguments">Arguments</a></h1>
<ul>
<li><code>a</code>: The index of the first bit</li>
<li><code>b</code>: The index of the second bit</li>
</ul>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">2u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">swap</span>(<span class="number">1</span>, <span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">8</span>);</pre></div>
</div><h4 id="method.reverse" class="method"><code>pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#681-711" title="goto source code">[src]</a></h4><div class="docblock"><p>Reverses the order of bits in the slice, in place.</p>
<h1 id="original-18" class="section-header"><a href="#original-18">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b1_1001100u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> ..].<span class="ident">reverse</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b1_0011001</span>);</pre></div>
</div><h4 id="method.iter" class="method"><code>pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;usize as <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;&gt;::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#734-736" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over the slice.</p>
<h1 id="original-19" class="section-header"><a href="#original-19">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">130u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iterator</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">nth</span>(<span class="number">5</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id="method.iter_mut" class="method"><code>pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;usize as <a class="trait" href="../../bitvec/slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;&gt;::<a class="type" href="../../bitvec/slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#757-759" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator that allows modifying each bit.</p>
<h1 id="original-20" class="section-header"><a href="#original-20">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#Method.iter_mut"><code>slice::iter_mut</code></a></p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">for</span> (<span class="ident">idx</span>, <span class="kw-2">mut</span> <span class="ident">elem</span>) <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">iter_mut</span>().<span class="ident">enumerate</span>() {
  <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">=</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b100_100_10</span>);</pre></div>
</div><h4 id="method.windows" class="method"><code>pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#797-800" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over all contiguous windows of length <code>size</code>. The
windows overlap. If the slice is shorter than <code>size</code>, the iterator
returns no values.</p>
<h1 id="original-21" class="section-header"><a href="#original-21">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">windows</span>(<span class="number">6</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">6</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">7</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> ..]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the slice is shorter than <code>size</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">windows</span>(<span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.chunks" class="method"><code>pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#838-841" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> bits, and <a href="#method.rchunks"><code>rchunks</code></a> for the same
iterator but starting at the end of the slice.</p>
<h1 id="original-22" class="section-header"><a href="#original-22">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">3</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> ..]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.chunks_mut" class="method"><code>pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#879-882" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for the
same iterator but starting at the end of the slice.</p>
<h1 id="original-23" class="section-header"><a href="#original-23">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">chunks_mut</span>(<span class="number">3</span>).<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">set</span>(<span class="number">2</span> <span class="op">-</span> <span class="ident">idx</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b01_010_100</span>);</pre></div>
</div><h4 id="method.chunks_exact" class="method"><code>pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#924-927" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <code>remainder</code> function of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may
optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.chunks"><code>chunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for the same
iterator but starting at the end of the slice.</p>
<h1 id="original-24" class="section-header"><a href="#original-24">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">3</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> ..]);</pre></div>
</div><h4 id="method.chunks_exact_mut" class="method"><code>pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: usize<br>) -&gt; <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#969-976" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the beginning length of the slice, then the last up to
<code>chunk_size-1</code> bits will be omitted and can be retrieved from the
<code>into_remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler may
optimize the resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.chunks_mut"><code>chunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for the same
iterator but starting at the end of the slice.</p>
<h1 id="original-25" class="section-header"><a href="#original-25">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">3</span>).<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">set</span>(<span class="ident">idx</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b00_010_001</span>);</pre></div>
</div><h4 id="method.rchunks" class="method"><code>pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1014-1017" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks"><code>chunks</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h1 id="original-26" class="section-header"><a href="#original-26">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> ..]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">2</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.rchunks_mut" class="method"><code>pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1055-1058" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks_mut"><code>chunks_mut</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h1 id="original-27" class="section-header"><a href="#original-27">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rchunks_mut</span>(<span class="number">3</span>).<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">set</span>(<span class="number">2</span> <span class="op">-</span> <span class="ident">idx</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b100_010_01</span>);</pre></div>
</div><h4 id="method.rchunks_exact" class="method"><code>pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: usize) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1101-1104" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size-1</code> bits
will be omitted and can be retrieved from the <code>remainder</code> function of
the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.rchunks"><code>rchunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact"><code>chunks_exact</code></a> for the same iterator
but starting at the beginning of the slice.</p>
<h1 id="original-28" class="section-header"><a href="#original-28">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> ..]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">2</span>]);</pre></div>
</div><h4 id="method.rchunks_exact_mut" class="method"><code>pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: usize<br>) -&gt; <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1144-1151" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size-1</code>
bits will be omitted and can be retrieved from the <code>into_remainder</code>
function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of
<a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">3</span>).<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">set</span>(<span class="ident">idx</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b001_010_00</span>);</pre></div>
</div><h4 id="method.split_at" class="method"><code>pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: usize) -&gt; (&amp;Self, &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1188-1192" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="original-29" class="section-header"><a href="#original-29">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xC3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();

<span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span>.<span class="ident">is_empty</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="ident">bits</span>);

<span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">2</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">right</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> ..]);

<span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">left</span>, <span class="ident">bits</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.split_at_mut" class="method"><code>pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: usize<br>) -&gt; (&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1241-1249" title="goto source code">[src]</a></h4><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h1 id="original-30" class="section-header"><a href="#original-30">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h1 id="api-differences-8" class="section-header"><a href="#api-differences-8">API Differences</a></h1>
<p>Because the partition point <code>mid</code> is permitted to occur in the interior
of a memory element <code>T</code>, this method is required to mark the returned
slices as being to aliased memory. This marking ensures that writes to
the covered memory use the appropriate synchronization behavior of your
build to avoid data races – by default, this makes all writes atomic; on
builds with the <code>atomic</code> feature disabled, this uses <code>Cell</code>s and
forbids the produced subslices from leaving the current thread.</p>
<p>See the <a href="../store/trait.BitStore.html"><code>BitStore</code></a> documentation for more information.</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="comment">// scoped to restrict the lifetime of the borrows</span>
{
  <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
  <span class="kw-2">*</span><span class="ident">left</span>.<span class="ident">get_mut</span>(<span class="number">1</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="kw-2">*</span><span class="ident">right</span>.<span class="ident">get_mut</span>(<span class="number">2</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b010_00100</span>);</pre></div>
</div><h4 id="method.split" class="method"><code>pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1311-1314" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>.
The matched bit is not contained in the subslices.</p>
<h1 id="original-31" class="section-header"><a href="#original-31">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h1 id="api-differences-9" class="section-header"><a href="#api-differences-9">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b01_001_000u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> ..]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the first bit is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last element in the slice is
matched, an empty slice will be the last item returned by the iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">7</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If two matched bits are directly adjacent, an empty slice will be
present between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_100_00u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">2</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">8</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.split_mut" class="method"><code>pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1343-1346" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>. The matched bit is not contained in the subslices.</p>
<h1 id="original-32" class="section-header"><a href="#original-32">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h1 id="api-differences-10" class="section-header"><a href="#api-differences-10">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">split_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="kw-2">*</span><span class="ident">group</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b101_100_11</span>);</pre></div>
</div><h4 id="method.rsplit" class="method"><code>pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1392-1395" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
starting at the end of the slice and working backwards. The matched bit
is not contained in the subslices.</p>
<h1 id="original-33" class="section-header"><a href="#original-33">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h1 id="api-differences-11" class="section-header"><a href="#api-differences-11">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0001_0000u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> ..]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">3</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>As with <code>split()</code>, if the first or last bit is matched, an empty slice
will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b1001_0001u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">7</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">3</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id="method.rsplit_mut" class="method"><code>pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1425-1428" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over mutable subslices separated by bits that match
<code>pred</code>, starting at the end of the slice and working backwards. The
matched bit is not contained in the subslices.</p>
<h1 id="original-34" class="section-header"><a href="#original-34">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h1 id="api-differences-12" class="section-header"><a href="#api-differences-12">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplit_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="kw-2">*</span><span class="ident">group</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b101_100_11</span>);</pre></div>
</div><h4 id="method.splitn" class="method"><code>pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1465-1468" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched bit is not contained
in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-35" class="section-header"><a href="#original-35">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h1 id="api-differences-13" class="section-header"><a href="#api-differences-13">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">2</span>) {
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">group</span>.<span class="ident">len</span>());
}
<span class="comment">//  2</span>
<span class="comment">//  5</span></pre></div>
</div><h4 id="method.splitn_mut" class="method"><code>pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1500-1503" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>,
limited to returning at most <code>n</code> items. The matched element is not
contained in the subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-36" class="section-header"><a href="#original-36">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h1 id="api-differences-14" class="section-header"><a href="#api-differences-14">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">splitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="kw-2">*</span><span class="ident">group</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b101_100_10</span>);</pre></div>
</div><h4 id="method.rsplitn" class="method"><code>pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1541-1544" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>
limited to returining at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-37" class="section-header"><a href="#original-37">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h1 id="api-differences-15" class="section-header"><a href="#api-differences-15">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">2</span>) {
  <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">group</span>.<span class="ident">len</span>());
}
<span class="comment">//  2</span>
<span class="comment">//  5</span></pre></div>
</div><h4 id="method.rsplitn_mut" class="method"><code>pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: usize, pred: F) -&gt; <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, P&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../bitvec/slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = &lt;<a class="struct" href="../../bitvec/slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, P&gt; as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, &amp;bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1577-1580" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns an iterator over subslices separated by bits that match <code>pred</code>
limited to returning at most <code>n</code> items. This starts at the end of the
slice and works backwards. The matched bit is not contained in the
subslices.</p>
<p>The last item returned, if any, will contain the remainder of the slice.</p>
<h1 id="original-38" class="section-header"><a href="#original-38">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h1 id="api-differences-16" class="section-header"><a href="#api-differences-16">API Differences</a></h1>
<p>In order to allow more than one bit of information for the split
decision, the predicate receives the index of each bit, as well as its
value.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="kw-2">*</span><span class="ident">group</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b101_000_11</span>);</pre></div>
</div><h4 id="method.contains" class="method"><code>pub fn <a href="#method.contains" class="fnname">contains</a>&lt;O2, T2&gt;(&amp;self, x: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1617-1627" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if the slice contains a subslice that matches the given
span.</p>
<h1 id="original-39" class="section-header"><a href="#original-39">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h1 id="api-differences-17" class="section-header"><a href="#api-differences-17">API Differences</a></h1>
<p>This searches for a matching subslice (allowing different type
parameters) rather than for a specific bit. Searching for a contained
element with a given value is not as useful on a collection of <code>bool</code>.</p>
<p>Furthermore, <code>BitSlice</code> defines <a href="#method.any"><code>any</code></a> and <a href="#method.not_all"><code>not_all</code></a>, which are
optimized searchers for any <code>true</code> or <code>false</code> bit, respectively, in a
sequence.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0101_1010u8</span>;
<span class="kw">let</span> <span class="ident">bits_msb</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_lsb</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits_msb</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">bits_lsb</span>[<span class="number">1</span> .. <span class="number">5</span>]));</pre></div>
<p>This example uses a palindrome pattern to demonstrate that the slice
being searched for does not need to have the same type parameters as the
slice being searched.</p>
</div><h4 id="method.starts_with" class="method"><code>pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1658-1665" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p>
<h1 id="original-40" class="section-header"><a href="#original-40">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">needle</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">5</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">haystack</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">needle</span>[.. <span class="number">2</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">haystack</span>.<span class="ident">starts_with</span>(<span class="ident">needle</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">haystack</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">haystack</span>[<span class="number">2</span> .. <span class="number">4</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="number">0u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>().<span class="ident">starts_with</span>(<span class="ident">empty</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">empty</span>.<span class="ident">starts_with</span>(<span class="ident">empty</span>));</pre></div>
</div><h4 id="method.ends_with" class="method"><code>pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;O2, T2&gt;(&amp;self, needle: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1696-1704" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p>
<h1 id="original-41" class="section-header"><a href="#original-41">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0100_1011u8</span>;
<span class="kw">let</span> <span class="ident">haystack</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">needle</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">3</span> .. <span class="number">6</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">haystack</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span><span class="ident">needle</span>[<span class="number">1</span> ..]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">haystack</span>.<span class="ident">ends_with</span>(<span class="ident">needle</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">haystack</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span><span class="ident">haystack</span>[<span class="number">2</span> .. <span class="number">4</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="number">0u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>().<span class="ident">ends_with</span>(<span class="ident">empty</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">empty</span>.<span class="ident">ends_with</span>(<span class="ident">empty</span>));</pre></div>
</div><h4 id="method.rotate_left" class="method"><code>pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1755-1791" title="goto source code">[src]</a></h4><div class="docblock"><p>Rotates the slice in-place such that the first <code>by</code> bits of the slice
move to the end while the last <code>self.len() - by</code> bits move to the front.
After calling <code>rotate_left</code>, the bit previously at index <code>by</code> will
become the first bit in the slice.</p>
<h1 id="original-42" class="section-header"><a href="#original-42">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#rotate_left"><code>slice::rotate_left</code></a></p>
<h1 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h1>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h1 id="complexity" class="section-header"><a href="#complexity">Complexity</a></h1>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h1 id="performance-1" class="section-header"><a href="#performance-1">Performance</a></h1>
<p>While this is faster than the equivalent rotation on <code>[bool]</code>, it is
slower than a handcrafted partial-element rotation on <code>[T]</code>. Because of
the support for custom orderings, and the lack of specialization, this
method can only accelerate by reducing the number of loop iterations
performed on the slice body, and cannot accelerate by using shift-mask
instructions to move multiple bits in one operation.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0xC3</span>);</pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_left</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b1_1101_000</span>);</pre></div>
</div><h4 id="method.rotate_right" class="method"><code>pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: usize)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1843-1865" title="goto source code">[src]</a></h4><div class="docblock"><p>Rotates the slice in-place such that the first <code>self.len() - by</code> bits of
the slice move to the end while the last <code>by</code> bits move to the front.
After calling <code>rotate_right</code>, the bit previously at index <code>self.len() - by</code> will become the first bit in the slice.</p>
<h1 id="original-43" class="section-header"><a href="#original-43">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#rotate_right"><code>slice::rotate_right</code></a></p>
<h1 id="panics-13" class="section-header"><a href="#panics-13">Panics</a></h1>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h1 id="complexity-1" class="section-header"><a href="#complexity-1">Complexity</a></h1>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h1 id="performance-2" class="section-header"><a href="#performance-2">Performance</a></h1>
<p>While this is faster than the equivalent rotation on <code>[bool]</code>, it is
slower than a handcrafted partial-element rotation on <code>[T]</code>. Because of
the support for custom orderings, and the lack of specialization, this
method can only accelerate by reducing the number of loop iterations
performed on the slice body, and cannot accelerate by using shift-mask
instructions to move multiple bits in one operation.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0x3C</span>);</pre></div>
<p>Rotate a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_right</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b1_0111_000</span>);</pre></div>
</div><h4 id="method.clone_from_bitslice" class="method"><code>pub fn <a href="#method.clone_from_bitslice" class="fnname">clone_from_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1926-1938" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<h1 id="original-44" class="section-header"><a href="#original-44">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>slice::clone_from_slice</code></a></p>
<h1 id="api-differences-18" class="section-header"><a href="#api-differences-18">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h1 id="panics-14" class="section-header"><a href="#panics-14">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<p>Cloning two bits from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0x0Fu16</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">2</span> .. <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0xC0</span>);</pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>clone_from_bitslice</code> on a
single slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">clone_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> ..]);</pre></div>
<p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="ident">head</span>.<span class="ident">clone_from_bitslice</span>(<span class="ident">tail</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0x33</span>);</pre></div>
</div><h4 id="method.copy_from_bitslice" class="method"><code>pub fn <a href="#method.copy_from_bitslice" class="fnname">copy_from_bitslice</a>(&amp;mut self, src: &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1980-1982" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<h1 id="original-45" class="section-header"><a href="#original-45">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.std.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h1 id="api-differences-19" class="section-header"><a href="#api-differences-19">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<p>This is unable to guarantee a strictly faster copy behavior than
<a href="#method.clone_from_bitslice"><code>clone_from_bitslice</code></a>. In the future, the implementation <em>may</em>
specialize, as the language allows.</p>
<h1 id="panics-15" class="section-header"><a href="#panics-15">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<p>Copying two bits from a slice into another:</p>
</div><h4 id="method.copy_within" class="method"><code>pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: usize) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2023-2034" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <code>self.len()</code>.</p>
<h1 id="original-46" class="section-header"><a href="#original-46">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h1 id="panics-16" class="section-header"><a href="#panics-16">Panics</a></h1>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p>Copying four bytes within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x07u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="ident">bits</span>.<span class="ident">copy_within</span>(<span class="number">5</span> .., <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0xE7</span>);</pre></div>
</div><h4 id="method.swap_with_bitslice" class="method"><code>pub fn <a href="#method.swap_with_bitslice" class="fnname">swap_with_bitslice</a>&lt;O2, T2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2071-2086" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps all bits in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h1 id="original-47" class="section-header"><a href="#original-47">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h1 id="api-differences-20" class="section-header"><a href="#api-differences-20">API Differences</a></h1>
<p>This method is renamed, as it takes a bit slice rather than an element
slice.</p>
<h1 id="panics-17" class="section-header"><a href="#panics-17">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one</span> <span class="op">=</span> [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">two</span> <span class="op">=</span> <span class="number">0x1234u16</span>;
<span class="kw">let</span> <span class="ident">one_bits</span> <span class="op">=</span> <span class="ident">one</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">two_bits</span> <span class="op">=</span> <span class="ident">two</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="ident">one_bits</span>.<span class="ident">swap_with_bitslice</span>(<span class="ident">two_bits</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">one</span>, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">two</span>, <span class="number">0x96A5</span>);</pre></div>
</div><h4 id="method.align_to" class="method"><code>pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; (&amp;Self, &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, &amp;Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2155-2184" title="goto source code">[src]</a></h4><div class="docblock"><p>Transmute the bitslice to a bitslice of another type, ensuring alignment
of the types is maintained.</p>
<p>This method splits the bitslice into three distinct bitslices: prefix,
correctly aligned middle bitslice of a new type, and the suffix
bitslice. The method may make the middle bitslice the greatest
length possible for a given type and input bitslice, but only your
algorithm's performance should depend on that, not its correctness. It
is permissible for all of the input data to be returned as the prefix or
suffix bitslice.</p>
<h1 id="original-48" class="section-header"><a href="#original-48">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h1 id="api-differences-21" class="section-header"><a href="#api-differences-21">API Differences</a></h1>
<p>Type <code>U</code> is <strong>required</strong> to have the same type family as type <code>T</code>.
Whatever <code>T</code> is of the fundamental integers, atomics, or <code>Cell</code>
wrappers, <code>U</code> must be a different width in the same family. Changing the
type family with this method is <strong>unsound</strong> and strictly forbidden.
Unfortunately, it cannot be guaranteed by this function, so you are
required to abide by this limitation.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle bitslice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
  <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
  <span class="kw">match</span> <span class="ident">prefix</span>.<span class="ident">len</span>() {
    <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> {
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[.. <span class="number">48</span>]);
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">suffix</span>, <span class="ident">bits</span>[<span class="number">48</span> ..]);
    },
    <span class="number">8</span> <span class="op">=</span><span class="op">&gt;</span> {
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">prefix</span>, <span class="ident">bits</span>[.. <span class="number">8</span>]);
      <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[<span class="number">8</span> ..]);
    },
    <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="macro">unreachable</span><span class="macro">!</span>(<span class="string">&quot;This case will not occur&quot;</span>)
  }
}</pre></div>
</div><h4 id="method.align_to_mut" class="method"><code>pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; (&amp;mut Self, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, &amp;mut Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2231-2241" title="goto source code">[src]</a></h4><div class="docblock"><p>Transmute the bitslice to a bitslice of another type, ensuring alignment
of the types is maintained.</p>
<p>This method splits the bitslice into three distinct bitslices: prefix,
correctly aligned middle bitslice of a new type, and the suffix
bitslice. The method may make the middle bitslice the greatest
length possible for a given type and input bitslice, but only your
algorithm's performance should depend on that, not its correctness. It
is permissible for all of the input data to be returned as the prefix or
suffix bitslice.</p>
<h1 id="original-49" class="section-header"><a href="#original-49">Original</a></h1>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h1 id="api-differences-22" class="section-header"><a href="#api-differences-22">API Differences</a></h1>
<p>Type <code>U</code> is <strong>required</strong> to have the same type family as type <code>T</code>.
Whatever <code>T</code> is of the fundamental integers, atomics, or <code>Cell</code>
wrappers, <code>U</code> must be a different width in the same family. Changing the
type family with this method is <strong>unsound</strong> and strictly forbidden.
Unfortunately, it cannot be guaranteed by this function, so you are
required to abide by this limitation.</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle bitslice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
  <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
  <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to_mut</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
  <span class="comment">//  same access and behavior as in `align_to`</span>
}</pre></div>
</div></div><h3 id="impl-1" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a href="#impl-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice.rs.html#415-650" title="goto source code">[src]</a></h3><div class="docblock"><p>Constructors are limited to integers only, and not their <code>Cell</code>s or atomics.</p>
</div><div class="impl-items"><h4 id="method.from_element" class="method"><code>pub fn <a href="#method.from_element" class="fnname">from_element</a>(elem: &amp;T) -&gt; &amp;Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#447-452" title="goto source code">[src]</a></h4><div class="docblock"><p>Constructs a shared <code>&amp;BitSlice</code> reference over a shared element.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>T</code> elements, provides a
method <a href="../view/trait.BitView.html#method.view_bits"><code>.view_bits::&lt;O&gt;()</code></a> which delegates to this function and may be
more convenient for you to write.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>elem</code>: A shared reference to a memory element.</li>
</ul>
<h1 id="returns" class="section-header"><a href="#returns">Returns</a></h1>
<p>A shared <code>&amp;BitSlice</code> over the <code>elem</code> element.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_element</span>(<span class="kw-2">&amp;</span><span class="ident">elem</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">8</span>);</pre></div>
</div><h4 id="method.from_element_mut" class="method"><code>pub fn <a href="#method.from_element_mut" class="fnname">from_element_mut</a>(elem: &amp;mut T) -&gt; &amp;mut Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#487-492" title="goto source code">[src]</a></h4><div class="docblock"><p>Constructs an exclusive <code>&amp;mut BitSlice</code> reference over an element.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>T</code> elements, provides a
method <a href="../view/trait.BitView.html#method.view_bits_mut"><code>.view_bits_mut::&lt;O&gt;()</code></a> which delegates to this function and
may be more convenient for you to write.</p>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>elem</code>: An exclusive reference to a memory element.</li>
</ul>
<h1 id="returns-1" class="section-header"><a href="#returns-1">Returns</a></h1>
<p>An exclusive <code>&amp;mut BitSlice</code> over the <code>elem</code> element.</p>
<p>Note that the original <code>elem</code> reference will be inaccessible for the
duration of the returned slice handle’s lifetime.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">elem</span> <span class="op">=</span> <span class="number">0u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_element_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">elem</span>);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">15</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">15</span>).<span class="ident">unwrap</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elem</span>, <span class="number">1</span>);</pre></div>
</div><h4 id="method.from_slice" class="method"><code>pub fn <a href="#method.from_slice" class="fnname">from_slice</a>(slice: &amp;[T]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;Self&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#531-539" title="goto source code">[src]</a></h4><div class="docblock"><p>Constructs a shared <code>&amp;BitSlice</code> reference over a shared element slice.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>[T]</code> slices, provides a
method <a href="../view/trait.BitView.html#method.view_bits"><code>.view_bits::&lt;O&gt;()</code></a> that is equivalent to this function and may
be more convenient for you to write.</p>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>slice</code>: A shared reference over a sequence of memory elements.</li>
</ul>
<h1 id="returns-2" class="section-header"><a href="#returns-2">Returns</a></h1>
<p>If <code>slice</code> does not have fewer than <a href="#associatedconstant.MAX_ELTS"><code>MAX_ELTS</code></a> elements, this returns
<code>None</code>. Otherwise, it returns a shared <code>&amp;BitSlice</code> over the <code>slice</code>
elements.</p>
<h1 id="conditions" class="section-header"><a href="#conditions">Conditions</a></h1>
<p>The produced <code>&amp;BitSlice</code> handle always begins at the zeroth bit.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0u8</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_slice</span>(<span class="ident">slice</span>).<span class="ident">unwrap</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">15</span>]);</pre></div>
<p>An example showing this function failing would require a slice exceeding
<code>!0usize &gt;&gt; 3</code> bytes in size, which is infeasible to produce.</p>
</div><h4 id="method.from_slice_unchecked" class="method"><code>pub unsafe fn <a href="#method.from_slice_unchecked" class="fnname">from_slice_unchecked</a>(slice: &amp;[T]) -&gt; &amp;Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#555-561" title="goto source code">[src]</a></h4><div class="docblock"><p>Converts a slice reference into a <code>BitSlice</code> reference without checking
that its size can be safely used.</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>If the <code>slice</code> length is too long, then it will be capped at
<a href="#associatedconstant.MAX_BITS"><code>MAX_BITS</code></a>. You are responsible for ensuring that the input slice is
not unduly truncated.</p>
<p>Prefer <a href="#method.from_slice"><code>from_slice</code></a>.</p>
</div><h4 id="method.from_slice_mut" class="method"><code>pub fn <a href="#method.from_slice_mut" class="fnname">from_slice_mut</a>(slice: &amp;mut [T]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut Self&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#623-629" title="goto source code">[src]</a></h4><div class="docblock"><p>Constructs an exclusive <code>&amp;mut BitSlice</code> reference over a slice.</p>
<p>The <a href="../view/trait.BitView.html"><code>BitView</code></a> trait, implemented on all <code>[T]</code> slices, provides a
method <a href="../view/trait.BitView.html#method.view_bits_mut"><code>.view_bits_mut::&lt;O&gt;()</code></a> that is equivalent to this function and
may be more convenient for you to write.</p>
<h1 id="parameters-3" class="section-header"><a href="#parameters-3">Parameters</a></h1>
<ul>
<li><code>slice</code>: An exclusive reference over a sequence of memory elements.</li>
</ul>
<h1 id="returns-3" class="section-header"><a href="#returns-3">Returns</a></h1>
<p>An exclusive <code>&amp;mut BitSlice</code> over the <code>slice</code> elements.</p>
<p>Note that the original <code>slice</code> reference will be inaccessible for the
duration of the returned slice handle’s lifetime.</p>
<h1 id="panics-18" class="section-header"><a href="#panics-18">Panics</a></h1>
<p>This panics if <code>slice</code> does not have fewer than <a href="#associatedconstant.MAX_ELTS"><code>MAX_ELTS</code></a> elements.</p>
<h1 id="conditions-1" class="section-header"><a href="#conditions-1">Conditions</a></h1>
<p>The produced <code>&amp;mut BitSlice</code> handle always begins at the zeroth bit of
the zeroth element in <code>slice</code>.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_slice_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>).<span class="ident">unwrap</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>[<span class="number">0</span>], <span class="number">1</span>);</pre></div>
<p>This example attempts to construct a <code>&amp;mut BitSlice</code> handle from a slice
that is too large to index. Either the <code>vec!</code> allocation will fail, or
the bit-slice constructor will fail.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0usize</span>; <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">MAX_ELTS</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="kw">_</span><span class="op">&gt;</span>::<span class="ident">from_slice_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[..]).<span class="ident">unwrap</span>();</pre></div>
</div><h4 id="method.from_slice_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.from_slice_unchecked_mut" class="fnname">from_slice_unchecked_mut</a>(slice: &amp;mut [T]) -&gt; &amp;mut Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#645-649" title="goto source code">[src]</a></h4><div class="docblock"><p>Converts a slice reference into a <code>BitSlice</code> reference without checking
that its size can be safely used.</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>If the <code>slice</code> length is too long, then it will be capped at
<a href="#associatedconstant.MAX_BITS"><code>MAX_BITS</code></a>. You are responsible for ensuring that the input slice is
not unduly truncated.</p>
<p>Prefer <a href="#method.from_slice_mut"><code>from_slice_mut</code></a>.</p>
</div></div><h3 id="impl-2" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice.rs.html#653-1785" title="goto source code">[src]</a></h3><div class="docblock"><p>Methods specific to <code>BitSlice&lt;_, T&gt;</code>, and not present on <code>[T]</code>.</p>
</div><div class="impl-items"><h4 id="method.empty" class="method"><code>pub fn <a href="#method.empty" class="fnname">empty</a>&lt;'a&gt;() -&gt; &amp;'a Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#670-672" title="goto source code">[src]</a></h4><div class="docblock"><p>Produces the empty slice. This is equivalent to <code>&amp;[]</code> for ordinary
slices.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="ident">empty</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.empty_mut" class="method"><code>pub fn <a href="#method.empty_mut" class="fnname">empty_mut</a>&lt;'a&gt;() -&gt; &amp;'a mut Self</code><a class="srclink" href="../../src/bitvec/slice.rs.html#686-688" title="goto source code">[src]</a></h4><div class="docblock"><p>Produces the empty mutable slice. This is equivalent to <code>&amp;mut []</code> for
ordinary slices.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="ident">empty_mut</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id="method.set" class="method"><code>pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: usize, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#730-736" title="goto source code">[src]</a></h4><div class="docblock"><p>Sets the bit value at the given position.</p>
<h1 id="parameters-4" class="section-header"><a href="#parameters-4">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the range <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be set, <code>true</code> for <code>1</code> and <code>false</code> for <code>0</code>.</li>
</ul>
<h1 id="effects" class="section-header"><a href="#effects">Effects</a></h1>
<p>If <code>index</code> is valid, then the bit to which it refers is set to <code>value</code>.</p>
<h1 id="panics-19" class="section-header"><a href="#panics-19">Panics</a></h1>
<p>This method panics if <code>index</code> is outside the slice domain.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">7</span>).<span class="ident">unwrap</span>());
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">7</span>, <span class="bool-val">true</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">7</span>).<span class="ident">unwrap</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">1</span>);</pre></div>
<p>This example panics when it attempts to set a bit that is out of bounds.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>::<span class="ident">empty_mut</span>();
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">false</span>);</pre></div>
</div><h4 id="method.set_unchecked" class="method"><code>pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: usize, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#784-786" title="goto source code">[src]</a></h4><div class="docblock"><p>Sets a bit at an index, without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.set"><code>set</code></a>.</p>
<h1 id="parameters-5" class="section-header"><a href="#parameters-5">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the range <code>0 .. self.len()</code>. It will not be checked.</li>
</ul>
<h1 id="effects-1" class="section-header"><a href="#effects-1">Effects</a></h1>
<p>The bit at <code>index</code> is set to <code>value</code>.</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">4</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">set_unchecked</span>(<span class="number">5</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">1</span>);</pre></div>
</div><h4 id="method.all" class="method"><code>pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#818-846" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h1 id="truth-table" class="section-header"><a href="#truth-table">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-6" class="section-header"><a href="#parameters-6">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-4" class="section-header"><a href="#returns-4">Returns</a></h1>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">all</span>());</pre></div>
</div><h4 id="method.any" class="method"><code>pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#878-895" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h1 id="truth-table-1" class="section-header"><a href="#truth-table-1">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1
</code></pre>
<h1 id="parameters-7" class="section-header"><a href="#parameters-7">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-5" class="section-header"><a href="#returns-5">Returns</a></h1>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">any</span>());</pre></div>
</div><h4 id="method.not_all" class="method"><code>pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#926-928" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h1 id="truth-table-2" class="section-header"><a href="#truth-table-2">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-8" class="section-header"><a href="#parameters-8">Parameters</a></h1>
<ul>
<li>`&amp;self</li>
</ul>
<h1 id="returns-6" class="section-header"><a href="#returns-6">Returns</a></h1>
<p>Whether any bit in the slice domain is unset.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_all</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_all</span>());</pre></div>
</div><h4 id="method.not_any" class="method"><code>pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#959-961" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h1 id="truth-table-3" class="section-header"><a href="#truth-table-3">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-9" class="section-header"><a href="#parameters-9">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-7" class="section-header"><a href="#returns-7">Returns</a></h1>
<p>Whether all bits in the slice domain are unset.</p>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_any</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_any</span>());</pre></div>
</div><h4 id="method.some" class="method"><code>pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1002-1004" title="goto source code">[src]</a></h4><div class="docblock"><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <a href="#method.all"><code>.all</code></a> or <a href="#method.not_any"><code>.not_any</code></a> are <code>true</code>.</p>
<h1 id="truth-table-4" class="section-header"><a href="#truth-table-4">Truth Table</a></h1>
<pre><code class="language-text">0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0
</code></pre>
<h1 id="parameters-10" class="section-header"><a href="#parameters-10">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-8" class="section-header"><a href="#returns-8">Returns</a></h1>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b111_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">3</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>].<span class="ident">some</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">some</span>());</pre></div>
</div><h4 id="method.count_ones" class="method"><code>pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1030-1052" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of ones in the memory region backing <code>self</code>.</p>
<h1 id="parameters-11" class="section-header"><a href="#parameters-11">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-9" class="section-header"><a href="#returns-9">Returns</a></h1>
<p>The number of high bits in the slice domain.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">count_ones</span>(), <span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">count_ones</span>(), <span class="number">0</span>);</pre></div>
</div><h4 id="method.count_zeros" class="method"><code>pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1078-1102" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the number of zeros in the memory region backing <code>self</code>.</p>
<h1 id="parameters-12" class="section-header"><a href="#parameters-12">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-10" class="section-header"><a href="#returns-10">Returns</a></h1>
<p>The number of low bits in the slice domain.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">count_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">count_zeros</span>(), <span class="number">4</span>);</pre></div>
</div><h4 id="method.set_all" class="method"><code>pub fn <a href="#method.set_all" class="fnname">set_all</a>(&amp;mut self, value: bool)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1126-1163" title="goto source code">[src]</a></h4><div class="docblock"><p>Sets all bits in the slice to a value.</p>
<h1 id="parameters-13" class="section-header"><a href="#parameters-13">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
<span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">5</span>].<span class="ident">set_all</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
<span class="ident">bits</span>[.. <span class="number">1</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</pre></div>
</div><h4 id="method.for_each" class="method"><code>pub fn <a href="#method.for_each" class="fnname">for_each</a>&lt;F&gt;(&amp;mut self, func: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(usize, bool) -&gt; bool,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1195-1204" title="goto source code">[src]</a></h4><div class="docblock"><p>Applies a function to each bit in the slice.</p>
<p><code>BitSlice</code> cannot implement <code>IndexMut</code>, as it cannot manifest <code>&amp;mut bool</code> references, and the <a href="../../bitvec/slice/struct.BitMut.html" title="BitMut"><code>BitMut</code></a> proxy reference has an unavoidable
overhead. This method bypasses both problems, by applying a function to
each pair of index and value in the slice, without constructing a proxy
reference.</p>
<h1 id="parameters-14" class="section-header"><a href="#parameters-14">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives two arguments, <code>index: usize</code> and
<code>value: bool</code>, and returns a <code>bool</code>.</li>
</ul>
<h1 id="effects-2" class="section-header"><a href="#effects-2">Effects</a></h1>
<p>For each index in the slice, the result of invoking <code>func</code> with the
index number and current bit value is written into the slice.</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">idx</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">3</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0b100_100_10</span>);</pre></div>
</div><h4 id="method.as_slice" class="method"><code>pub fn <a href="#method.as_slice" class="fnname">as_slice</a>(&amp;self) -&gt; &amp;[T]</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1225-1229" title="goto source code">[src]</a></h4><div class="docblock"><p>Accesses the total backing storage of the <code>BitSlice</code>, as a slice of its
elements.</p>
<p>This method produces a slice over all the memory elements it touches,
using the current storage parameter. This is safe to do, as any events
that would create an aliasing view into the elements covered by the
returned slice will also have caused the slice to use its alias-aware
type.</p>
<h1 id="parameters-15" class="section-header"><a href="#parameters-15">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-11" class="section-header"><a href="#returns-11">Returns</a></h1>
<p>A view of the entire memory region this slice covers, including the edge
elements.</p>
</div><h4 id="method.as_raw_slice" class="method"><code>pub fn <a href="#method.as_raw_slice" class="fnname">as_raw_slice</a>(&amp;self) -&gt; &amp;[T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>]</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1273-1275" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the wholly-filled elements of the <code>BitSlice</code>.</p>
<p>This will not include partially-owned edge elements, as they may be
aliased by other handles. To gain access to all elements that the
<code>BitSlice</code> region covers, use one of the following:</p>
<ul>
<li><a href="#method.as_slice"><code>.as_slice</code></a> produces a shared slice over all elements, marked
aliased as appropriate.</li>
<li><a href="#method.domain"><code>.domain</code></a> produces a view describing each component of the region,
marking only the contended edges as aliased and the uncontended
interior as unaliased.</li>
</ul>
<h1 id="parameters-16" class="section-header"><a href="#parameters-16">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-12" class="section-header"><a href="#returns-12">Returns</a></h1>
<p>A slice of all the wholly-filled elements in the <code>BitSlice</code> backing
storage.</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">66</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="ident">accum</span> <span class="op">=</span> <span class="ident">bits</span>
  .<span class="ident">as_raw_slice</span>()
  .<span class="ident">iter</span>()
  .<span class="ident">copied</span>()
  .<span class="ident">map</span>(<span class="ident">u8</span>::<span class="ident">count_ones</span>)
  .<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">accum</span>, <span class="number">3</span>);</pre></div>
</div><h4 id="method.as_raw_slice_mut" class="method"><code>pub fn <a href="#method.as_raw_slice_mut" class="fnname">as_raw_slice_mut</a>(&amp;mut self) -&gt; &amp;mut [T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>]</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1315-1317" title="goto source code">[src]</a></h4><div class="docblock"><p>Views the wholly-filled elements of the <code>BitSlice</code>.</p>
<p>This will not include partially-owned edge elements, as they may be
aliased by other handles. To gain access to all elements that the
<code>BitSlice</code> region covers, use one of the following:</p>
<ul>
<li><a href="#method.as_aliased_slice"><code>.as_aliased_slice</code></a> produces a shared slice over all elements,
marked as aliased to allow for the possibliity of mutation.</li>
<li><a href="#method.domain_mut"><code>.domain_mut</code></a> produces a view describing each component of the
region, marking only the contended edges as aliased and the
uncontended interior as unaliased.</li>
</ul>
<h1 id="parameters-17" class="section-header"><a href="#parameters-17">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-13" class="section-header"><a href="#returns-13">Returns</a></h1>
<p>A mutable slice of all the wholly-filled elements in the <code>BitSlice</code>
backing storage.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">64</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">for</span> <span class="ident">elt</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">as_raw_slice_mut</span>() {
  <span class="kw-2">*</span><span class="ident">elt</span> <span class="op">|</span><span class="op">=</span> <span class="number">2</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">66</span>], <span class="ident">bits</span>.<span class="ident">as_slice</span>());</pre></div>
</div><h4 id="method.bit_domain" class="method"><code>pub fn <a href="#method.bit_domain" class="fnname">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../../bitvec/domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1403-1405" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into the logical components of its memory domain.</p>
<p>This produces a set of read-only subslices, marking as much as possible
as affirmatively lacking any write-capable view (<code>T::NoAlias</code>). The
unaliased view is able to safely perform unsynchronized reads from
memory without causing undefined behavior, as the type system is able to
statically prove that no other write-capable views exist.</p>
<h1 id="parameters-18" class="section-header"><a href="#parameters-18">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-14" class="section-header"><a href="#returns-14">Returns</a></h1>
<p>A <code>BitDomain</code> structure representing the logical components of the
memory region.</p>
<h1 id="safety-exception" class="section-header"><a href="#safety-exception">Safety Exception</a></h1>
<p>The following snippet describes a means of constructing a <code>T::NoAlias</code>
view into memory that is, in fact, aliased:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">sync</span>::<span class="ident">atomic</span>::<span class="ident">AtomicU8</span>;
<span class="kw">type</span> <span class="ident">Bs</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">T</span><span class="op">&gt;</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="ident">AtomicU8</span>::<span class="ident">new</span>(<span class="number">0</span>), <span class="ident">AtomicU8</span>::<span class="ident">new</span>(<span class="number">0</span>), <span class="ident">AtomicU8</span>::<span class="ident">new</span>(<span class="number">0</span>)];
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">Bs</span><span class="op">&lt;</span><span class="ident">AtomicU8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">subslice</span>: <span class="kw-2">&amp;</span><span class="ident">Bs</span><span class="op">&lt;</span><span class="ident">AtomicU8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">20</span>];

<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">noalias</span>, <span class="kw">_</span>): (<span class="kw">_</span>, <span class="kw-2">&amp;</span><span class="ident">Bs</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>, <span class="kw">_</span>) <span class="op">=</span>
  <span class="ident">subslice</span>.<span class="ident">bit_domain</span>().<span class="ident">region</span>().<span class="ident">unwrap</span>();</pre></div>
<p>The <code>noalias</code> reference, which has memory type <code>u8</code>, assumes that it can
act as an <code>&amp;u8</code> reference: unsynchronized loads are permitted, as no
handle exists which is capable of modifying the middle bit of <code>data</code>.
This means that LLVM is permitted to issue loads from memory <em>wherever</em>
it wants in the block during which <code>noalias</code> is live, as all loads are
equivalent.</p>
<p>Use of the <code>bits</code> or <code>subslice</code> handles, which are still live for the
lifetime of <code>noalias</code>, to issue <a href="#method.set_aliased"><code>.set_aliased</code></a> calls into the middle
element introduce <strong>undefined behavior</strong>. <code>bitvec</code> permits safe code to
introduce this undefined behavior solely because it requires deliberate
opt-in – you must start from atomic data; this cannot occur when <code>data</code>
is non-atomic – and use of the shared-mutation facility simultaneously
with the unaliasing view.</p>
<p>The <a href="#method.set_aliased"><code>.set_aliased</code></a> method is speculative, and will be marked as
<code>unsafe</code> or removed at any suspicion that its presence in the library
has any costs.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<p>This method can be used to accelerate reads from a slice that is marked
as aliased.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">type</span> <span class="ident">Bs</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">T</span><span class="op">&gt;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>): (
  <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Bs</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span>,
  <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">Bs</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span>,
) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="kw">let</span> (<span class="ident">partial</span>, <span class="ident">full</span>, <span class="kw">_</span>): (
  <span class="kw-2">&amp;</span><span class="ident">Bs</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Alias</span><span class="op">&gt;</span>,
  <span class="kw-2">&amp;</span><span class="ident">Bs</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span>::<span class="ident">Mem</span><span class="op">&gt;</span>,
  <span class="kw">_</span>,
) <span class="op">=</span> <span class="ident">b</span>.<span class="ident">bit_domain</span>().<span class="ident">region</span>().<span class="ident">unwrap</span>();
<span class="ident">read_from</span>(<span class="ident">partial</span>); <span class="comment">// uses alias-aware reads</span>
<span class="ident">read_from</span>(<span class="ident">full</span>); <span class="comment">// uses ordinary reads</span></pre></div>
</div><h4 id="method.bit_domain_mut" class="method"><code>pub fn <a href="#method.bit_domain_mut" class="fnname">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../bitvec/domain/enum.BitDomainMut.html" title="enum bitvec::domain::BitDomainMut">BitDomainMut</a>&lt;'_, O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1430-1432" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into the logical components of its memory domain.</p>
<p>This produces a set of mutable subslices, marking as much as possible as
affirmatively lacking any other view (<code>T::Mem</code>). The bare view is able
to safely perform unsynchronized reads from and writes to memory without
causing undefined behavior, as the type system is able to statically
prove that no other views exist.</p>
<h1 id="why-this-is-more-sound-than-bit_domain" class="section-header"><a href="#why-this-is-more-sound-than-bit_domain">Why This Is More Sound Than <code>.bit_domain</code></a></h1>
<p>The <code>&amp;mut</code> exclusion rule makes it impossible to construct two
references over the same memory where one of them is marked <code>&amp;mut</code>. This
makes it impossible to hold a live reference to memory <em>separately</em> from
any references produced from this method. For the duration of all
references produced by this method, all ancestor references used to
reach this method call are either suspended or dead, and the compiler
will not allow you to use them.</p>
<p>As such, this method cannot introduce undefined behavior where a
reference incorrectly believes that the referent memory region is
immutable.</p>
</div><h4 id="method.domain" class="method"><code>pub fn <a href="#method.domain" class="fnname">domain</a>(&amp;self) -&gt; <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><h3 class="notable">Notable traits for <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../../bitvec/domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'a, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="type">Item</a> = T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></div></span></span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1473-1475" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into immutable references to its underlying memory
components.</p>
<p>Unlike <a href="#method.bit_domain"><code>.bit_domain</code></a> and <a href="#method.bit_domain_mut"><code>.bit_domain_mut</code></a>, this does not return
smaller <code>BitSlice</code> handles but rather appropriately-marked references to
the underlying memory elements.</p>
<p>The aliased references allow mutation of these elements. You are
required to not use mutating methods on these references <em>at all</em>. This
function is not marked <code>unsafe</code>, but this is a contract you must uphold.
Use <a href="#method.domain_mut"><code>.domain_mut</code></a> to modify the underlying elements.</p>
<blockquote>
<p>It is not currently possible to forbid mutation through these
references. This may change in the future.</p>
</blockquote>
<h1 id="safety-exception-1" class="section-header"><a href="#safety-exception-1">Safety Exception</a></h1>
<p>As with <a href="#method.bit_domain"><code>.bit_domain</code></a>, this produces unsynchronized immutable
references over the fully-populated interior elements. If this view is
constructed from a <code>BitSlice</code> handle over atomic memory, then it will
remove the atomic access behavior for the interior elements. This <em>by
itself</em> is safe, as long as no contemporaneous atomic writes to that
memory can occur. You must not retain and use an atomic reference to the
memory region marked as <code>NoAlias</code> for the duration of this view’s
existence.</p>
<h1 id="parameters-19" class="section-header"><a href="#parameters-19">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h1 id="returns-15" class="section-header"><a href="#returns-15">Returns</a></h1>
<p>A read-only descriptor of the memory elements backing <code>*self</code>.</p>
</div><h4 id="method.domain_mut" class="method"><code>pub fn <a href="#method.domain_mut" class="fnname">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../bitvec/domain/enum.DomainMut.html" title="enum bitvec::domain::DomainMut">DomainMut</a>&lt;'_, T&gt;</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1502-1504" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits the slice into mutable references to its underlying memory
elements.</p>
<p>Like <a href="#method.domain"><code>.domain</code></a>, this returns appropriately-marked references to the
underlying memory elements. These references are all writable.</p>
<p>The aliased edge references permit modifying memory beyond their bit
marker. You are required to only mutate the region of these edge
elements that you currently govern. This function is not marked
<code>unsafe</code>, but this is a contract you must uphold.</p>
<blockquote>
<p>It is not currently possible to forbid out-of-bounds mutation through
these references. This may change in the future.</p>
</blockquote>
<h1 id="parameters-20" class="section-header"><a href="#parameters-20">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h1 id="returns-16" class="section-header"><a href="#returns-16">Returns</a></h1>
<p>A descriptor of the memory elements underneath <code>*self</code>, permitting
mutation.</p>
</div><h4 id="method.split_at_unchecked" class="method"><code>pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: usize) -&gt; (&amp;Self, &amp;Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1545-1551" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits a slice at some mid-point, without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.split_at"><code>split_at</code></a>.</p>
<h1 id="parameters-21" class="section-header"><a href="#parameters-21">Parameters</a></h1>
<ul>
<li><code>&amp;self</code></li>
<li><code>mid</code>: The index at which to split the slice. This must be in the
range <code>0 .. self.len()</code>.</li>
</ul>
<h1 id="returns-17" class="section-header"><a href="#returns-17">Returns</a></h1>
<ul>
<li><code>.0</code>: <code>&amp;self[.. mid]</code></li>
<li><code>.1</code>: <code>&amp;self[mid ..]</code></li>
</ul>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>This function is <strong>not</strong> safe. It performs raw pointer arithmetic to
construct two new references. If <code>mid</code> is out of bounds, then the first
slice will be too large, and the second will be <em>catastrophically</em>
incorrect. As both are references to invalid memory, they are undefined
to <em>construct</em>, and may not ever be used.</p>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x0180u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> (<span class="ident">one</span>, <span class="ident">two</span>) <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">split_at_unchecked</span>(<span class="number">8</span>) };
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">one</span>[<span class="number">7</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">two</span>[<span class="number">0</span>]);</pre></div>
</div><h4 id="method.split_at_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fnname">split_at_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: usize<br>) -&gt; (&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;, &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>&gt;)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1595-1611" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits a mutable slice at some mid-point, without checking boundary
conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.split_at_mut"><code>split_at_mut</code></a>.</p>
<h1 id="parameters-22" class="section-header"><a href="#parameters-22">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>mid</code>: The index at which to split the slice. This must be in the
range <code>0 .. self.len()</code>.</li>
</ul>
<h1 id="returns-18" class="section-header"><a href="#returns-18">Returns</a></h1>
<ul>
<li><code>.0</code>: <code>&amp;mut self[.. mid]</code></li>
<li><code>.1</code>: <code>&amp;mut self[mid ..]</code></li>
</ul>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>This function is <strong>not</strong> safe. It performs raw pointer arithmetic to
construct two new references. If <code>mid</code> is out of bounds, then the first
slice will be too large, and the second will be <em>catastrophically</em>
incorrect. As both are references to invalid memory, they are undefined
to <em>construct</em>, and may not ever be used.</p>
<h1 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u16</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> (<span class="ident">one</span>, <span class="ident">two</span>) <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">split_at_unchecked_mut</span>(<span class="number">8</span>) };
<span class="ident">one</span>.<span class="ident">set</span>(<span class="number">7</span>, <span class="bool-val">true</span>);
<span class="ident">two</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0x0180u16</span>);</pre></div>
</div><h4 id="method.swap_unchecked" class="method"><code>pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: usize, b: usize)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1650-1655" title="goto source code">[src]</a></h4><div class="docblock"><p>Swaps the bits at two indices without checking boundary conditions.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.swap"><code>swap</code></a>.</p>
<h1 id="parameters-23" class="section-header"><a href="#parameters-23">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>a</code>: One index to swap.</li>
<li><code>b</code>: The other index to swap.</li>
</ul>
<h1 id="effects-3" class="section-header"><a href="#effects-3">Effects</a></h1>
<p>The bit at index <code>a</code> is written into index <code>b</code>, and the bit at index <code>b</code>
is written into <code>a</code>.</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p>Both <code>a</code> and <code>b</code> must be less than <code>self.len()</code>. Indices greater than
the length will cause out-of-bounds memory access, which can lead to
memory unsafety and a program crash.</p>
<h1 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">8u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">swap_unchecked</span>(<span class="number">0</span>, <span class="number">4</span>); }

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">128</span>);</pre></div>
</div><h4 id="method.copy_unchecked" class="method"><code>pub unsafe fn <a href="#method.copy_unchecked" class="fnname">copy_unchecked</a>(&amp;mut self, from: usize, to: usize)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1694-1697" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies a bit from one index to another without checking boundary
conditions.</p>
<h1 id="parameters-24" class="section-header"><a href="#parameters-24">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>from</code>: The index whose bit is to be copied</li>
<li><code>to</code>: The index into which the copied bit is written.</li>
</ul>
<h1 id="effects-4" class="section-header"><a href="#effects-4">Effects</a></h1>
<p>The bit at <code>from</code> is written into <code>to</code>.</p>
<h1 id="safety-9" class="section-header"><a href="#safety-9">Safety</a></h1>
<p>Both <code>from</code> and <code>to</code> must be less than <code>self.len()</code>, in order for
<code>self</code> to legally read from and write to them, respectively.</p>
<p>If <code>self</code> had been split from a larger slice, reading from <code>from</code> or
writing to <code>to</code> may not <em>necessarily</em> cause a memory-safety violation in
the Rust model, due to the aliasing system <code>bitvec</code> employs. However,
writing outside the bounds of a slice reference is <em>always</em> a logical
error, as it causes changes observable by another reference handle.</p>
<h1 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">copy_unchecked</span>(<span class="number">0</span>, <span class="number">2</span>) };

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">5</span>);</pre></div>
</div><h4 id="method.copy_within_unchecked" class="method"><code>pub unsafe fn <a href="#method.copy_within_unchecked" class="fnname">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: usize) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;usize&gt;,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice.rs.html#1733-1749" title="goto source code">[src]</a></h4><div class="docblock"><p>Copies bits from one part of the slice to another part of itself.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <code>self.len()</code>.</p>
<h1 id="effects-5" class="section-header"><a href="#effects-5">Effects</a></h1>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.end() - src.start()]</code>.</p>
<h1 id="panics-20" class="section-header"><a href="#panics-20">Panics</a></h1>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h1 id="safety-10" class="section-header"><a href="#safety-10">Safety</a></h1>
<p>Both the <code>src</code> range and the target range <code>dest .. dest + src.len()</code>
must not exceed the <code>self.len()</code> slice range.</p>
<h1 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x07u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">copy_within_unchecked</span>(<span class="number">5</span> .., <span class="number">0</span>); }

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, <span class="number">0xE7</span>);</pre></div>
</div></div><h3 id="impl-3" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../radium/trait.Radium.html" title="trait radium::Radium">Radium</a>&lt;&lt;T as <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>&gt;::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>&gt;,&nbsp;</span></code><a href="#impl-3" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice.rs.html#1788-1854" title="goto source code">[src]</a></h3><div class="docblock"><p>Methods available only when <code>T</code> allows shared mutability.</p>
</div><div class="impl-items"><h4 id="method.split_at_aliased_mut" class="method"><code>pub fn <a href="#method.split_at_aliased_mut" class="fnname">split_at_aliased_mut</a>(&amp;mut self, mid: usize) -&gt; (&amp;mut Self, &amp;mut Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1820-1827" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits a mutable slice at some mid-point.</p>
<p>This method has the same behavior as <a href="#method.split_at_mut"><code>split_at_mut</code></a>, except that it
does not apply an aliasing marker to the partitioned subslices.</p>
<h1 id="safety-11" class="section-header"><a href="#safety-11">Safety</a></h1>
<p>Because this method is defined only on <code>BitSlice</code>s whose <code>T</code> type is
alias-safe, the subslices do not need to be additionally marked.</p>
</div><h4 id="method.split_at_aliased_unchecked_mut" class="method"><code>pub unsafe fn <a href="#method.split_at_aliased_unchecked_mut" class="fnname">split_at_aliased_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: usize<br>) -&gt; (&amp;mut Self, &amp;mut Self)</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1844-1853" title="goto source code">[src]</a></h4><div class="docblock"><p>Splits a mutable slice at some mid-point, without checking boundary
conditions.</p>
<p>This method has the same behavior as <a href="#method.split_at_unchecked_mut"><code>split_at_unchecked_mut</code></a>, except
that it does not apply an aliasing marker to the partitioned subslices.</p>
<h1 id="safety-12" class="section-header"><a href="#safety-12">Safety</a></h1>
<p>See <a href="#method.split_at_unchecked_mut"><code>split_at_unchecked_mut</code></a> for safety requirements.</p>
<p>Because this method is defined only on <code>BitSlice</code>s whose <code>T</code> type is
alias-safe, the subslices do not need to be additionally marked.</p>
</div></div><h3 id="impl-4" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-4" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice.rs.html#1857-1887" title="goto source code">[src]</a></h3><div class="docblock"><p>Miscellaneous information.</p>
</div><div class="impl-items"><h4 id="associatedconstant.MAX_BITS" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_BITS" class="constant"><b>MAX_BITS</b></a>: usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1871" title="goto source code">[src]</a></h4><div class="docblock"><p>The inclusive maximum length of a <code>BitSlice&lt;_, T&gt;</code>.</p>
<p>As <code>BitSlice</code> is zero-indexed, the largest possible index is one less
than this value.</p>
<table><thead><tr><th align="right">CPU word width</th><th align="right">Value</th></tr></thead><tbody>
<tr><td align="right">32 bits</td><td align="right"><code>0x1fff_ffff</code></td></tr>
<tr><td align="right">64 bits</td><td align="right"><code>0x1fff_ffff_ffff_ffff</code></td></tr>
</tbody></table>
</div><h4 id="associatedconstant.MAX_ELTS" class="associatedconstant"><code>pub const <a href="#associatedconstant.MAX_ELTS" class="constant"><b>MAX_ELTS</b></a>: usize</code><a class="srclink" href="../../src/bitvec/slice.rs.html#1886" title="goto source code">[src]</a></h4><div class="docblock"><p>The inclusive maximum length that a slice <code>[T]</code> can be for
<code>BitSlice&lt;_, T&gt;</code> to cover it.</p>
<p>A <code>BitSlice&lt;_, T&gt;</code> that begins in the interior of an element and
contains the maximum number of bits will extend one element past the
cutoff that would occur if the slice began at the zeroth bit. Such a
slice must be manually constructed, but will not otherwise fail.</p>
<table><thead><tr><th align="right">Type Bits</th><th align="right">Max Elements (32-bit)</th><th align="right">Max Elements (64-bit)</th></tr></thead><tbody>
<tr><td align="right">8</td><td align="right"><code>0x0400_0001</code></td><td align="right"><code>0x0400_0000_0000_0001</code></td></tr>
<tr><td align="right">16</td><td align="right"><code>0x0200_0001</code></td><td align="right"><code>0x0200_0000_0000_0001</code></td></tr>
<tr><td align="right">32</td><td align="right"><code>0x0100_0001</code></td><td align="right"><code>0x0100_0000_0000_0001</code></td></tr>
<tr><td align="right">64</td><td align="right"><code>0x0080_0001</code></td><td align="right"><code>0x0080_0000_0000_0001</code></td></tr>
</tbody></table>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-AsMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#144-153" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#150-152" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-AsRef%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#132-141" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_ref" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#138-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#200-209" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_ref-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</code><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#206-208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Binary" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Binary" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#469" title="goto source code">[src]</a></h3><div class="docblock"><p>Render the contents of a <code>BitSlice</code> in a numeric format.</p>
<p>These implementations render the bits of memory contained in a
<code>BitSlice</code> as one of the three numeric bases that the Rust format
system supports:</p>
<ul>
<li><code>Binary</code> renders each bit individually as <code>0</code> or <code>1</code>,</li>
<li><code>Octal</code> renders clusters of three bits as the numbers <code>0</code> through
<code>7</code>,</li>
<li>and <code>UpperHex</code> and <code>LowerHex</code> render clusters of four bits as the
numbers <code>0</code> through <code>9</code> and <code>A</code> through <code>F</code>.</li>
</ul>
<p>The formatters produce a “word” for each element <code>T</code> of memory. The
chunked formats (octal and hexadecimal) operate somewhat peculiarly:
they show the semantic value of the memory, as interpreted by the
ordering parameter’s implementation rather than the raw value of
memory you might observe with a debugger. In order to ease the
process of expanding numbers back into bits, each digit is grouped to
the right edge of the memory element. So, for example, the byte
<code>0xFF</code> would be rendered in as <code>0o377</code> rather than <code>0o773</code>.</p>
<p>Rendered words are chunked by memory elements, rather than by as
clean as possible a number of digits, in order to aid visualization
of the slice’s place in memory.</p>
</div><div class="impl-items"><h4 id="method.fmt-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#469" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-BitAndAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = bool&gt;,&nbsp;</span></code><a href="#impl-BitAndAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#32-42" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitand_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#38-41" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></p>
</div></div><h3 id="impl-BitField" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../bitvec/field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;<a class="struct" href="../../bitvec/order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-BitField" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#300-458" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#304-356" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using little-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le">Read more</a></p>
</div><h4 id="method.load_be" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#359-391" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using big-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be">Read more</a></p>
</div><h4 id="method.store_le" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#394-422" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using little-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le">Read more</a></p>
</div><h4 id="method.store_be" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#425-457" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using big-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be">Read more</a></p>
</div><h4 id="method.load" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#129-136" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads the bits in the <code>self</code> region into a local value. <a href="../../bitvec/field/trait.BitField.html#method.load">Read more</a></p>
</div><h4 id="method.store" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#170-177" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../../bitvec/field/trait.BitField.html#method.store">Read more</a></p>
</div></div><h3 id="impl-BitField-1" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../bitvec/field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;<a class="struct" href="../../bitvec/order/struct.Msb0.html" title="struct bitvec::order::Msb0">Msb0</a>, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-BitField-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#460-619" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#464-501" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using little-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le">Read more</a></p>
</div><h4 id="method.load_be-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#504-542" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads from <code>self</code>, using big-endian element <code>T</code> ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be">Read more</a></p>
</div><h4 id="method.store_le-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#545-580" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using little-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le">Read more</a></p>
</div><h4 id="method.store_be-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#583-618" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores into <code>self</code>, using big-endian element ordering. <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be">Read more</a></p>
</div><h4 id="method.load-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#129-136" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Loads the bits in the <code>self</code> region into a local value. <a href="../../bitvec/field/trait.BitField.html#method.load">Read more</a></p>
</div><h4 id="method.store-1" class="method hidden"><code>fn <a href="../../bitvec/field/trait.BitField.html#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#170-177" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../../bitvec/field/trait.BitField.html#method.store">Read more</a></p>
</div></div><h3 id="impl-BitOrAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = bool&gt;,&nbsp;</span></code><a href="#impl-BitOrAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#44-54" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitor_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#50-53" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></p>
</div></div><h3 id="impl-BitXorAssign%3CRhs%3E" class="impl"><code class="in-band">impl&lt;O, T, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = bool&gt;,&nbsp;</span></code><a href="#impl-BitXorAssign%3CRhs%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#56-66" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.bitxor_assign" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#62-65" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#35-44" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#41-43" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#47-56" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#53-55" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#289-302" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#295-301" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-Default" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Default" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#266-275" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.default" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#272-274" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id="impl-Default-1" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Default-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#277-286" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.default-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#283-285" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id="impl-Display" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Display" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#305-314" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#311-313" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id="impl-Eq" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Eq" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#43-48" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Hash" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Hash" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#476-488" title="goto source code">[src]</a></h3><div class="docblock"><p>Writes the contents of the <code>BitSlice</code>, in semantic bit order, into a hasher.</p>
</div><div class="impl-items"><h4 id="method.hash" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, hasher: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#482-487" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id="method.hash_slice" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#184-186" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id="impl-Index%3CRange%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRange%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;usize&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3CRangeFrom%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-3" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;usize&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3CRangeFull%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRangeFull%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-4" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3CRangeInclusive%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-5" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;usize&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3CRangeTo%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-6" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;usize&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3CRangeToInclusive%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-7" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index-6" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;usize&gt;) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-Index%3Cusize%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;usize&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Index%3Cusize%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#68-103" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" class="type">Output</a> = bool</code></h4><div class='docblock'><p>The returned type after indexing.</p>
</div><h4 id="method.index" class="method"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: usize) -&gt; &amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#100-102" title="goto source code">[src]</a></h4><div class="docblock"><p>Looks up a single bit by semantic index.</p>
<h1 id="examples-75" class="section-header"><a href="#examples-75">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">7</span>]); <span class="comment">// --------------------------^  |  |</span>
<span class="macro">assert</span><span class="macro">!</span>( <span class="ident">bits</span>[<span class="number">8</span>]); <span class="comment">// -----------------------------^  |</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">9</span>]); <span class="comment">// --------------------------------^</span></pre></div>
<p>If the index is greater than or equal to the length, indexing will
panic.</p>
<p>The below test will panic when accessing index 1, as only index 0 is
valid.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits</span><span class="macro">!</span>[<span class="number">0</span>,  ];
<span class="ident">bits</span>[<span class="number">1</span>]; <span class="comment">// --------^</span></pre></div>
</div></div><h3 id="impl-IndexMut%3CRange%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;usize&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CRangeFrom%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;usize&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CRangeFull%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRangeFull%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;usize&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CRangeTo%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;usize&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;usize&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.index_mut-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: <a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;usize&gt;) -&gt; &amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#133-140" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the mutable indexing (<code>container[index]</code>) operation.</p>
</div></div><h3 id="impl-IntoIterator" class="impl"><code class="in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IntoIterator" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#211-236" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.IntoIter" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../../bitvec/slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;</code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id="associatedtype.Item" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &lt;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id="method.into_iter" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#219-235" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id="impl-IntoIterator-1" class="impl"><code class="in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: 'a + <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-IntoIterator-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#407-433" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.IntoIter-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="type">IntoIter</a> = <a class="struct" href="../../bitvec/slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;</code></h4><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div><h4 id="associatedtype.Item-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="type">Item</a> = &lt;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a> as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a></code></h4><div class='docblock'><p>The type of the elements being iterated over.</p>
</div><h4 id="method.into_iter-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></code><a class="srclink" href="../../src/bitvec/slice/iter.rs.html#415-432" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><h3 id="impl-LowerHex" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-LowerHex" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#471" title="goto source code">[src]</a></h3><div class="docblock"><p>Render the contents of a <code>BitSlice</code> in a numeric format.</p>
<p>These implementations render the bits of memory contained in a
<code>BitSlice</code> as one of the three numeric bases that the Rust format
system supports:</p>
<ul>
<li><code>Binary</code> renders each bit individually as <code>0</code> or <code>1</code>,</li>
<li><code>Octal</code> renders clusters of three bits as the numbers <code>0</code> through
<code>7</code>,</li>
<li>and <code>UpperHex</code> and <code>LowerHex</code> render clusters of four bits as the
numbers <code>0</code> through <code>9</code> and <code>A</code> through <code>F</code>.</li>
</ul>
<p>The formatters produce a “word” for each element <code>T</code> of memory. The
chunked formats (octal and hexadecimal) operate somewhat peculiarly:
they show the semantic value of the memory, as interpreted by the
ordering parameter’s implementation rather than the raw value of
memory you might observe with a debugger. In order to ease the
process of expanding numbers back into bits, each digit is grouped to
the right edge of the memory element. So, for example, the byte
<code>0xFF</code> would be rendered in as <code>0o377</code> rather than <code>0o773</code>.</p>
<p>Rendered words are chunked by memory elements, rather than by as
clean as possible a number of digits, in order to aid visualization
of the slice’s place in memory.</p>
</div><div class="impl-items"><h4 id="method.fmt-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#471" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-Not" class="impl"><code class="in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Not" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#142-170" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Output" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" class="type">Output</a> = Self</code></h4><div class='docblock'><p>The resulting type after applying the <code>!</code> operator.</p>
</div><h4 id="method.not" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></code><a class="srclink" href="../../src/bitvec/slice/ops.rs.html#149-169" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/nightly/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></p>
</div></div><h3 id="impl-Octal" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Octal" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#470" title="goto source code">[src]</a></h3><div class="docblock"><p>Render the contents of a <code>BitSlice</code> in a numeric format.</p>
<p>These implementations render the bits of memory contained in a
<code>BitSlice</code> as one of the three numeric bases that the Rust format
system supports:</p>
<ul>
<li><code>Binary</code> renders each bit individually as <code>0</code> or <code>1</code>,</li>
<li><code>Octal</code> renders clusters of three bits as the numbers <code>0</code> through
<code>7</code>,</li>
<li>and <code>UpperHex</code> and <code>LowerHex</code> render clusters of four bits as the
numbers <code>0</code> through <code>9</code> and <code>A</code> through <code>F</code>.</li>
</ul>
<p>The formatters produce a “word” for each element <code>T</code> of memory. The
chunked formats (octal and hexadecimal) operate somewhat peculiarly:
they show the semantic value of the memory, as interpreted by the
ordering parameter’s implementation rather than the raw value of
memory you might observe with a debugger. In order to ease the
process of expanding numbers back into bits, each digit is grouped to
the right edge of the memory element. So, for example, the byte
<code>0xFF</code> would be rendered in as <code>0o377</code> rather than <code>0o773</code>.</p>
<p>Rendered words are chunked by memory elements, rather than by as
clean as possible a number of digits, in order to aid visualization
of the slice’s place in memory.</p>
</div><div class="impl-items"><h4 id="method.fmt-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#470" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-Ord" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Ord" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#50-60" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.cmp" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, rhs: &amp;Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#56-59" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an <a href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div><h4 id="method.max" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#723-725" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div><h4 id="method.min" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#743-745" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div><h4 id="method.clamp" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</code><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#768-770" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></div><h3 id="impl-PartialEq%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#115-126" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#123-125" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-4" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#129-140" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#137-139" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-5" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E" class="impl"><code class="in-band">impl&lt;O, V, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3CBitArray%3CO%2C%20V%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#78-88" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#85-87" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#69-80" title="goto source code">[src]</a></h3><div class="docblock"><p>Tests if two <code>BitSlice</code>s are semantically — not bitwise — equal.</p>
<p>It is valid to compare slices of different ordering or memory types.</p>
<p>The equality condition requires that they have the same length and that at each
index, the two slices have the same bit value.</p>
</div><div class="impl-items"><h4 id="method.eq-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#76-79" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E-1" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#85-96" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#93-95" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-2" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E-2" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialEq%3CBitSlice%3CO2%2C%20T2%3E%3E-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#99-110" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.eq-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; bool</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#107-109" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id="method.ne-3" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id="impl-PartialOrd%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#198-209" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-4" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#206-208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-4" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-4" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-4" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-4" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E-1" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CO2%2C%20T2%3E%3E-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#239-250" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-7" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#247-249" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-7" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-7" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-7" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-7" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#211-222" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#219-221" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-5" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-5" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-5" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-5" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E-1" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3C%26%27_%20mut%20BitSlice%3CO2%2C%20T2%3E%3E-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#226-237" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-6" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#234-236" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-6" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-6" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-6" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-6" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E" class="impl"><code class="in-band">impl&lt;O, V, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3CBitArray%3CO%2C%20V%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#105-115" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#112-114" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#149-166" title="goto source code">[src]</a></h3><div class="docblock"><p>Compares two <code>BitSlice</code>s by semantic — not bitwise — ordering.</p>
<p>The comparison sorts by testing at each index if one slice has a high bit where
the other has a low. At the first index where the slices differ, the slice with
the high bit is greater. If the slices are equal until at least one terminates,
then they are compared by length.</p>
</div><div class="impl-items"><h4 id="method.partial_cmp-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#156-165" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-1" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E-1" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#170-181" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#178-180" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-2" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-2" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-2" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-2" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E-2" class="impl"><code class="in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;&gt; for &amp;mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O1, T1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-PartialOrd%3CBitSlice%3CO2%2C%20T2%3E%3E-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#183-194" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.partial_cmp-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#191-193" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div><h4 id="method.lt-3" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#963" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div><h4 id="method.le-3" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#982" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div><h4 id="method.gt-3" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1000" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div><h4 id="method.ge-3" class="method hidden"><code><span class="docblock attributes">#[must_use]</span>pub fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1019" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><h3 id="impl-Pointer" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-Pointer" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#318-328" title="goto source code">[src]</a></h3><div class="docblock"><p>Renders a <code>BitSlice</code> handle as its pointer representation.</p>
</div><div class="impl-items"><h4 id="method.fmt-6" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#324-327" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Threadsafe" title="type bitvec::store::BitStore::Threadsafe">Threadsafe</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#490-496" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T::<a class="type" href="../../bitvec/store/trait.BitStore.html#associatedtype.Threadsafe" title="type bitvec::store::BitStore::Threadsafe">Threadsafe</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#498-504" title="goto source code">[src]</a></h3><div class="impl-items"></div><h3 id="impl-TryFrom%3C%26%27_%20BitSlice%3CO2%2C%20T%3E%3E" class="impl"><code class="in-band">impl&lt;O, O2, T, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'_ <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T&gt;&gt; for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27_%20BitSlice%3CO2%2C%20T%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#168-186" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O2, T&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#178-185" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20%5BT%5D%3E" class="impl"><code class="in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a [T]&gt; for &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a> + <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20%5BT%5D%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#253-264" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-3" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = &amp;'a [T]</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-3" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(slice: &amp;'a [T]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#261-263" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for &amp;'a <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#189-206" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-1" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;'a <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#197-205" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="impl"><code class="in-band">impl&lt;'a, O, V&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;&amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, &lt;V as <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>&gt;::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;&gt; for &amp;'a mut <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TryFrom%3C%26%27a%20mut%20BitSlice%3CO%2C%20%3CV%20as%20BitView%3E%3A%3AStore%3E%3E" class="anchor"></a><a class="srclink" href="../../src/bitvec/array/traits.rs.html#209-226" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-2" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = TryFromBitSliceError</code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-2" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(src: &amp;'a mut <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="../../src/bitvec/array/traits.rs.html#217-225" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-UpperHex" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-UpperHex" class="anchor"></a><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#472" title="goto source code">[src]</a></h3><div class="docblock"><p>Render the contents of a <code>BitSlice</code> in a numeric format.</p>
<p>These implementations render the bits of memory contained in a
<code>BitSlice</code> as one of the three numeric bases that the Rust format
system supports:</p>
<ul>
<li><code>Binary</code> renders each bit individually as <code>0</code> or <code>1</code>,</li>
<li><code>Octal</code> renders clusters of three bits as the numbers <code>0</code> through
<code>7</code>,</li>
<li>and <code>UpperHex</code> and <code>LowerHex</code> render clusters of four bits as the
numbers <code>0</code> through <code>9</code> and <code>A</code> through <code>F</code>.</li>
</ul>
<p>The formatters produce a “word” for each element <code>T</code> of memory. The
chunked formats (octal and hexadecimal) operate somewhat peculiarly:
they show the semantic value of the memory, as interpreted by the
ordering parameter’s implementation rather than the raw value of
memory you might observe with a debugger. In order to ease the
process of expanding numbers back into bits, each digit is grouped to
the right edge of the memory element. So, for example, the byte
<code>0xFF</code> would be rendered in as <code>0o377</code> rather than <code>0o773</code>.</p>
<p>Rendered words are chunked by memory elements, rather than by as
clean as possible a number of digits, in order to aid visualization
of the slice’s place in memory.</p>
</div><div class="impl-items"><h4 id="method.fmt-5" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../../src/bitvec/slice/traits.rs.html#472" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter.</p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href="#impl-Unpin" class="anchor"></a><a class="srclink" href="../../src/bitvec/lib.rs.html#1" title="goto source code">[src]</a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#207-211" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-218" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#215" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-Conv" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.Conv.html" title="trait wyz::conv::Conv">Conv</a> for T</code><a href="#impl-Conv" class="anchor"></a><a class="srclink" href="../../src/wyz/conv.rs.html#107-108" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.conv" class="method hidden"><code>pub fn <a href="../../wyz/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/wyz/conv.rs.html#101-102" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Converts <code>self</code> into a target type. <a href="../../wyz/conv/trait.Conv.html#method.conv">Read more</a></p>
</div></div><h3 id="impl-FmtForward" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</code><a href="#impl-FmtForward" class="anchor"></a><a class="srclink" href="../../src/wyz/fmt.rs.html#93-94" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt_binary" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fnname">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#39-40" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted.</p>
</div><h4 id="method.fmt_display" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fnname">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#46-47" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display">Read more</a></p>
</div><h4 id="method.fmt_lower_exp" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fnname">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#53-54" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp">Read more</a></p>
</div><h4 id="method.fmt_lower_hex" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fnname">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#60-61" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex">Read more</a></p>
</div><h4 id="method.fmt_octal" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fnname">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#66-67" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted.</p>
</div><h4 id="method.fmt_pointer" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fnname">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#73-74" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer">Read more</a></p>
</div><h4 id="method.fmt_upper_exp" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fnname">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#80-81" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp">Read more</a></p>
</div><h4 id="method.fmt_upper_hex" class="method hidden"><code>pub fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fnname">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,&nbsp;</span></code><a class="srclink" href="../../src/wyz/fmt.rs.html#87-88" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-549" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#534-541" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Pipe" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.Pipe.html" title="trait wyz::pipe::Pipe">Pipe</a> for T</code><a href="#impl-Pipe" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#345-346" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</code><a class="srclink" href="../../src/wyz/pipe.rs.html#89-90" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a value into a function that cannot ordinarily be called in suffix
position. <a href="../../wyz/pipe/trait.Pipe.html#method.pipe">Read more</a></p>
</div></div><h3 id="impl-PipeAsRef" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeAsRef.html" title="trait wyz::pipe::PipeAsRef">PipeAsRef</a> for T</code><a href="#impl-PipeAsRef" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#354-355" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_as_ref" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#254-258" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_ref">Read more</a></p>
</div><h4 id="method.pipe_as_mut" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#278-285" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeAsRef.html#method.pipe_as_mut">Read more</a></p>
</div></div><h3 id="impl-PipeBorrow" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeBorrow.html" title="trait wyz::pipe::PipeBorrow">PipeBorrow</a> for T</code><a href="#impl-PipeBorrow" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#351-352" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_borrow" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#191-195" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait borrow into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow">Read more</a></p>
</div><h4 id="method.pipe_borrow_mut" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#224-231" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a trait mutable borrow into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeBorrow.html#method.pipe_borrow_mut">Read more</a></p>
</div></div><h3 id="impl-PipeDeref" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeDeref.html" title="trait wyz::pipe::PipeDeref">PipeDeref</a> for T</code><a href="#impl-PipeDeref" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#357-358" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_deref" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#307-313" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a dereference into a function that cannot normally be called in
suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref">Read more</a></p>
</div><h4 id="method.pipe_deref_mut" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#333-339" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a mutable dereference into a function that cannot normally be
called in suffix position. <a href="../../wyz/pipe/trait.PipeDeref.html#method.pipe_deref_mut">Read more</a></p>
</div></div><h3 id="impl-PipeRef" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/pipe/trait.PipeRef.html" title="trait wyz::pipe::PipeRef">PipeRef</a> for T</code><a href="#impl-PipeRef" class="anchor"></a><a class="srclink" href="../../src/wyz/pipe.rs.html#348-349" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.pipe_ref" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#130-131" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a reference into a function that cannot ordinarily be called in
suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_ref">Read more</a></p>
</div><h4 id="method.pipe_mut" class="method hidden"><code>pub fn <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut" class="fnname">pipe_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;'a mut Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></code><a class="srclink" href="../../src/wyz/pipe.rs.html#158-159" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Pipes a mutable reference into a function that cannot ordinarily be
called in suffix position. <a href="../../wyz/pipe/trait.PipeRef.html#method.pipe_mut">Read more</a></p>
</div></div><h3 id="impl-Tap" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.Tap.html" title="trait wyz::tap::Tap">Tap</a> for T</code><a href="#impl-Tap" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#340-341" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap" class="fnname">tap</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#278-281" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access for inspection. <a href="../../wyz/tap/trait.Tap.html#method.tap">Read more</a></p>
</div><h4 id="method.tap_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#290-293" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_mut" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#316-319" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access for modification. <a href="../../wyz/tap/trait.Tap.html#method.tap_mut">Read more</a></p>
</div><h4 id="method.tap_mut_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#328-331" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_mut</code> in debug builds, and does nothing in release builds.</p>
</div></div><h3 id="impl-TapAsRef%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapAsRef.html" title="trait wyz::tap::TapAsRef">TapAsRef</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TapAsRef%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#560-561" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_ref" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref" class="fnname">tap_ref</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#512-515" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access to the reference for inspection.</p>
</div><h4 id="method.tap_ref_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#524-527" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_ref</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_ref_mut" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#536-539" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access to the reference for modification.</p>
</div><h4 id="method.tap_ref_mut_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapAsRef.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#548-551" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_ref_mut</code> in debug builds, and does nothing in release builds.</p>
</div></div><h3 id="impl-TapBorrow%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="../../wyz/tap/trait.TapBorrow.html" title="trait wyz::tap::TapBorrow">TapBorrow</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TapBorrow%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#438-439" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_borrow" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#385-389" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides immutable access to the borrow for inspection. <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow">Read more</a></p>
</div><h4 id="method.tap_borrow_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#398-402" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_borrow</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_borrow_mut" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#411-415" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Provides mutable access to the borrow for modification.</p>
</div><h4 id="method.tap_borrow_mut_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut T) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#425-429" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_borrow_mut</code> in debug builds, and does nothing in release
builds. <a href="../../wyz/tap/trait.TapBorrow.html#method.tap_borrow_mut_dbg">Read more</a></p>
</div></div><h3 id="impl-TapDeref" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/tap/trait.TapDeref.html" title="trait wyz::tap::TapDeref">TapDeref</a> for T</code><a href="#impl-TapDeref" class="anchor"></a><a class="srclink" href="../../src/wyz/tap.rs.html#636-637" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.tap_deref" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref" class="fnname">tap_deref</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#589-592" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably dereferences <code>self</code> for inspection.</p>
</div><h4 id="method.tap_deref_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#600-603" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_deref</code> in debug builds, and does nothing in release builds.</p>
</div><h4 id="method.tap_deref_mut" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#612-615" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences <code>self</code> for modification.</p>
</div><h4 id="method.tap_deref_mut_dbg" class="method hidden"><code>pub fn <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;F, R&gt;(self, func: F) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a>) -&gt; R,&nbsp;</span></code><a class="srclink" href="../../src/wyz/tap.rs.html#624-627" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Calls <code>tap_deref_mut</code> in debug builds, and does nothing in release
builds. <a href="../../wyz/tap/trait.TapDeref.html#method.tap_deref_mut_dbg">Read more</a></p>
</div></div><h3 id="impl-TryConv" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/conv/trait.TryConv.html" title="trait wyz::conv::TryConv">TryConv</a> for T</code><a href="#impl-TryConv" class="anchor"></a><a class="srclink" href="../../src/wyz/conv.rs.html#209-210" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.try_conv" class="method hidden"><code>pub fn <a href="../../wyz/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,&nbsp;</span></code><a class="srclink" href="../../src/wyz/conv.rs.html#203-204" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Attempts to convert <code>self</code> into a target type. <a href="../../wyz/conv/trait.TryConv.html#method.try_conv">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#582-591" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-4" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from-4" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#588" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#568-577" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-5" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>