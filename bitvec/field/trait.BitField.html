<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `BitField` trait in crate `bitvec`."><meta name="keywords" content="rust, rustlang, rust-lang, BitField"><title>bitvec::field::BitField - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Trait BitField</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#required-methods">Required Methods</a><div class="sidebar-links"><a href="#tymethod.load_le">load_le</a><a href="#tymethod.load_be">load_be</a><a href="#tymethod.store_le">store_le</a><a href="#tymethod.store_be">store_be</a></div><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.store">store</a><a href="#method.load">load</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class="location"><a href="../index.html">bitvec</a>::<wbr><a href="index.html">field</a></p><div id="sidebar-vars" data-name="BitField" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">bitvec</a>::<wbr><a href="index.html">field</a>::<wbr><a class="trait" href="">BitField</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/bitvec/field.rs.html#282-715" title="goto source code">[src]</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust trait">pub trait BitField {
    fn <a href="#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>;
<div class="item-spacer"></div>    fn <a href="#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>;
<div class="item-spacer"></div>    fn <a href="#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M)<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>;
<div class="item-spacer"></div>    fn <a href="#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M)<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>;

    fn <a href="#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>,
    { ... }
<div class="item-spacer"></div>    fn <a href="#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M)<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a></span>,
    { ... }
}</pre></div><div class="docblock"><p>Performs C-style bitfield access through a <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>.</p>
<p>This trait transfers data between a <a href="../../bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a> region and a local integer. The
trait functions always place the live bits of the value against the least
significant bit edge of the local integer (the return value of the load methods,
and the argument value of the store methods).</p>
<p>Methods should be called as <code>bits[start .. end].load_or_store()</code>, where the
range subslice selects no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> element width.</p>
<h1 id="target-specific-behavior" class="section-header"><a href="#target-specific-behavior">Target-Specific Behavior</a></h1>
<p>When you are using this trait to manage memory that never leaves your machine,
you can use the <a href="../../bitvec/field/trait.BitField.html#method.load"><code>load</code></a> and <a href="../../bitvec/field/trait.BitField.html#method.store"><code>store</code></a> methods. However, if you are using this
trait to operate on a de/serialization buffer, where the exact bit pattern in
memory is important to your work and/or you need to be aware of the processor
byte endianness, you must not use these methods.</p>
<p>Instead, use <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le"><code>load_le</code></a>, <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be"><code>load_be</code></a>, <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le"><code>store_le</code></a>, or<a href="../../bitvec/field/trait.BitField.html#tymethod.store_be"><code>store_be</code></a> directly.</p>
<p>The un-suffixed methods choose their implementation based on the target
processor byte endianness; the suffixed methods have a consistent and fixed
behavior.</p>
<h1 id="element--and-bit--ordering-combinations" class="section-header"><a href="#element--and-bit--ordering-combinations">Element- and Bit- Ordering Combinations</a></h1>
<p>The <code>_le</code> and <code>_be</code> method suffices refer to the significance of successive
elements <code>T</code> in memory, while the <code>BitOrder</code> trait refers to the order that bits
within a single element <code>T</code> are traversed. The <code>BitField</code> methods and the
<code>BitOrder</code> implementors are <em><strong>not</strong></em> related.</p>
<p>When a load or store operation is contained in only one memory element, then the
<code>_le</code> and <code>_be</code> methods have the same behavior. They differ when the operation
must touch more than one element.</p>
<p>The module documentation contains a more detailed explanation, and examples, for
this behavior.</p>
</div><h2 id="required-methods" class="small-section-header">Required methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><h3 id="tymethod.load_le" class="method"><code>fn <a href="#tymethod.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#461-462" title="goto source code">[src]</a></h3><div class="docblock"><p>Loads from <code>self</code>, using little-endian element <code>T</code> ordering.</p>
<p>This function interprets a multi-element slice as having its least
significant chunk in the low memory address, and its most significant
chunk in the high memory address. Each element <code>T</code> is still interpreted
from individual bytes according to the local CPU ordering.</p>
<h1 id="parameters" class="section-header"><a href="#parameters">Parameters</a></h1>
<ul>
<li><code>&amp;self</code>: A read reference to some bits in memory. This slice must be
trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the type
being loaded. This can be accomplished with range indexing on a larger
slice.</li>
</ul>
<h1 id="returns" class="section-header"><a href="#returns">Returns</a></h1>
<p>A value <code>M</code> whose least <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> significant bits are filled with
the bits of <code>self</code>. If <code>self</code> spans multiple elements <code>T</code>, then the
lowest-address <code>T</code> is interpreted as containing the least significant
bits of the return value <code>M</code>, and the highest-address <code>T</code> is interpreted
as containing its most significant bits.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>This example shows how a value is segmented across multiple storage
elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">store_le</span>(<span class="number">0b0000_1_1011_1000_110u16</span>);
<span class="comment">//                 O PQRS TUVW XYZ</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b00000_110</span>, <span class="number">0b1011_1000</span>, <span class="number">0b1_0000000</span>
<span class="comment">//        XYZ    PQRS TUVW    O</span>
]);

<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b0000_1_1011_1000_110</span>,
<span class="comment">//       O PQRS TUVW XYZ</span>
);</pre></div>
<p>And this example shows how the same memory region will be read by
different <code>BitOrder</code> implementors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="comment">// Bit pos:   14                                     19  16</span>
<span class="comment">// Lsb0:     ─┤                                       ├──┤</span>
<span class="kw">let</span> <span class="ident">arr</span> <span class="op">=</span> [<span class="number">0b0100_0000_0000_0011u16</span>, <span class="number">0b0001_0000_0000_1110u16</span>];
<span class="comment">// Msb0:                      ├─       ├──┤</span>
<span class="comment">// Bit pos:                  14       16  19</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">arr</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">14</span> .. <span class="number">20</span>].<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>(),
  <span class="number">0b111001</span>,
);
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">arr</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">14</span> .. <span class="number">20</span>].<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>(),
  <span class="number">0b000111</span>,
);</pre></div>
</div><h3 id="tymethod.load_be" class="method"><code>fn <a href="#tymethod.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#545-546" title="goto source code">[src]</a></h3><div class="docblock"><p>Loads from <code>self</code>, using big-endian element <code>T</code> ordering.</p>
<p>This function interprets a multi-element slice as having its most
significant chunk in the low memory address, and its least significant
chunk in the high memory address. Each element <code>T</code> is still interpreted
from individual bytes according to the local CPU ordering.</p>
<h1 id="parameters-1" class="section-header"><a href="#parameters-1">Parameters</a></h1>
<ul>
<li><code>&amp;self</code>: A read reference to some bits in memory. This slice must be
trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the type
being loaded. This can be accomplished with range indexing on a larger
slice.</li>
</ul>
<h1 id="returns-1" class="section-header"><a href="#returns-1">Returns</a></h1>
<p>A value <code>M</code> whose least <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> significant bits are filled with
the bits of <code>self</code>. If <code>self</code> spans multiple elements <code>T</code>, then the
lowest-address <code>T</code> is interpreted as containing the most significant
bits of the return value <code>M</code>, and the highest-address <code>T</code> is interpreted
as containing its least significant bits.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>This example shows how a value is segmented across multiple storage
elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">store_be</span>(<span class="number">0b0000_110_1000_1011_1u16</span>);
<span class="comment">//                 OPQ RSTU VWXY Z</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b00000_110</span>, <span class="number">0b1000_1011</span>, <span class="number">0b1_0000000</span>
<span class="comment">//        OPQ    RSTU VWXY    Z</span>
]);

<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b0000_110_1000_1011_1</span>,
<span class="comment">//       OPQ RSTU VWXY Z</span>
);</pre></div>
<p>And this example shows how the same memory region will be read by
different <code>BitOrder</code> implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="comment">// Bit pos:   14                                     19  16</span>
<span class="comment">// Lsb0:     ─┤                                       ├──┤</span>
<span class="kw">let</span> <span class="ident">arr</span> <span class="op">=</span> [<span class="number">0b0100_0000_0000_0011u16</span>, <span class="number">0b0001_0000_0000_1110u16</span>];
<span class="comment">// Msb0:                      ├─       ├──┤</span>
<span class="comment">// Bit pos:                  14       15  19</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">arr</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">14</span> .. <span class="number">20</span>].<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>(),
  <span class="number">0b011110</span>,
);
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">arr</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">14</span> .. <span class="number">20</span>].<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>(),
  <span class="number">0b110001</span>,
);</pre></div>
</div><h3 id="tymethod.store_le" class="method"><code>fn <a href="#tymethod.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#629-630" title="goto source code">[src]</a></h3><div class="docblock"><p>Stores into <code>self</code>, using little-endian element ordering.</p>
<p>This function interprets a multi-element slice as having its least
significant chunk in the low memory address, and its most significant
chunk in the high memory address. Each element <code>T</code> is still interpreted
from individual bytes according to the local CPU ordering.</p>
<h1 id="parameters-2" class="section-header"><a href="#parameters-2">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code>: A write reference to some bits in memory. This slice must
be trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the
type being stored. This can be accomplished with range indexing on a
larger slice.</li>
<li><code>value</code>: A value, whose <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits will be
stored into <code>self</code>.</li>
</ul>
<h1 id="behavior" class="section-header"><a href="#behavior">Behavior</a></h1>
<p>The <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits of <code>value</code> are written into
the domain of <code>self</code>. If <code>self</code> spans multiple elements <code>T</code>, then the
lowest-address <code>T</code> is interpreted as containing the least significant
bits of the <code>M</code> return value, and the highest-address <code>T</code> is interpreted
as containing its most significant bits.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>This example shows how a value is segmented across multiple storage
elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">store_le</span>(<span class="number">0b0000_1_1011_1000_110u16</span>);
<span class="comment">//                 O PQRS TUVW XYZ</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b110_00000</span>, <span class="number">0b1011_1000</span>, <span class="number">0b0000000_1</span>
<span class="comment">//  XYZ          PQRS TUVW            O</span>
]);

<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b0000_1_1011_1000_110u16</span>,
<span class="comment">//       O PQRS TUVW XYZ</span>
);</pre></div>
<p>And this example shows how the same memory region is written by
different <code>BitOrder</code> implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lsb0</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Lsb0</span>, <span class="ident">u16</span>; <span class="number">0</span>; <span class="number">32</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">msb0</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Msb0</span>, <span class="ident">u16</span>; <span class="number">0</span>; <span class="number">32</span>];

<span class="comment">// Bit pos:        14                                     19  16</span>
<span class="comment">// Lsb0:          ─┤                                       ├──┤</span>
<span class="kw">let</span> <span class="ident">exp_lsb0</span> <span class="op">=</span> [<span class="number">0b0100_0000_0000_0000u16</span>, <span class="number">0b0000_0000_0000_1110u16</span>];
<span class="kw">let</span> <span class="ident">exp_msb0</span> <span class="op">=</span> [<span class="number">0b0000_0000_0000_0011u16</span>, <span class="number">0b0001_0000_0000_0000u16</span>];
<span class="comment">// Msb0:                           ├─       ├──┤</span>
<span class="comment">// Bit pos:                       14       15  19</span>

<span class="ident">lsb0</span>[<span class="number">14</span> ..<span class="op">=</span> <span class="number">19</span>].<span class="ident">store_le</span>(<span class="number">0b111001u8</span>);
<span class="ident">msb0</span>[<span class="number">14</span> ..<span class="op">=</span> <span class="number">19</span>].<span class="ident">store_le</span>(<span class="number">0b000111u8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">lsb0</span>.<span class="ident">as_raw_slice</span>(), <span class="ident">exp_lsb0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">msb0</span>.<span class="ident">as_raw_slice</span>(), <span class="ident">exp_msb0</span>);</pre></div>
</div><h3 id="tymethod.store_be" class="method"><code>fn <a href="#tymethod.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#713-714" title="goto source code">[src]</a></h3><div class="docblock"><p>Stores into <code>self</code>, using big-endian element ordering.</p>
<p>This function interprets a multi-element slice as having its most
significant chunk in the low memory address, and its least significant
chunk in the high memory address. Each element <code>T</code> is still interpreted
from individual bytes according to the local CPU ordering.</p>
<h1 id="parameters-3" class="section-header"><a href="#parameters-3">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code>: A write reference to some bits in memory. This slice must
be trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the
type being stored. This can be accomplished with range indexing on a
larger slice.</li>
<li><code>value</code>: A value, whose <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits will be
stored into <code>self</code>.</li>
</ul>
<h1 id="behavior-1" class="section-header"><a href="#behavior-1">Behavior</a></h1>
<p>The <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits of <code>value</code> are written into
the domain of <code>self</code>. If <code>self</code> spans multiple elements <code>T</code>, then the
lowest-address <code>T</code> is interpreted as containing the most significant
bits of the <code>M</code> return value, and the highest-address <code>T</code> is interpreted
as containing its least significant bits.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>This example shows how a value is segmented across multiple storage
elements:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">store_be</span>(<span class="number">0b0000_110_1000_1011_1u16</span>);
<span class="comment">//                 OPQ RSTU VWXY Z</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b110_00000</span>, <span class="number">0b1000_1011</span>, <span class="number">0b0000000_1</span>
<span class="comment">//  OPQ          RSTU VWXY            Z</span>
]);

<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()
  [<span class="number">5</span> .. <span class="number">17</span>]
  .<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b0000_110_1000_1011_1u16</span>,
<span class="comment">//       OPQ RSTU VWXY Z</span>
);</pre></div>
<p>And this example shows how the same memory region is written by
different <code>BitOrder</code> implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lsb0</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Lsb0</span>, <span class="ident">u16</span>; <span class="number">0</span>; <span class="number">32</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">msb0</span> <span class="op">=</span> <span class="macro">bitarr</span><span class="macro">!</span>[<span class="ident">Msb0</span>, <span class="ident">u16</span>; <span class="number">0</span>; <span class="number">32</span>];

<span class="comment">// Bit pos:        14                                     19  16</span>
<span class="comment">// Lsb0:          ─┤                                       ├──┤</span>
<span class="kw">let</span> <span class="ident">exp_lsb0</span> <span class="op">=</span> [<span class="number">0b0100_0000_0000_0000u16</span>, <span class="number">0b0000_0000_0000_1110u16</span>];
<span class="kw">let</span> <span class="ident">exp_msb0</span> <span class="op">=</span> [<span class="number">0b0000_0000_0000_0011u16</span>, <span class="number">0b0001_0000_0000_0000u16</span>];
<span class="comment">// Msb0:                           ├─       ├──┤</span>
<span class="comment">// Bit pos:                       14       15  19</span>

<span class="ident">lsb0</span>[<span class="number">14</span> ..<span class="op">=</span> <span class="number">19</span>].<span class="ident">store_be</span>(<span class="number">0b011110u8</span>);
<span class="ident">msb0</span>[<span class="number">14</span> ..<span class="op">=</span> <span class="number">19</span>].<span class="ident">store_be</span>(<span class="number">0b110001u8</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">lsb0</span>.<span class="ident">as_raw_slice</span>(), <span class="ident">exp_lsb0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">msb0</span>.<span class="ident">as_raw_slice</span>(), <span class="ident">exp_msb0</span>);</pre></div>
</div></div><span class="loading-content">Loading content...</span><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><h3 id="method.load" class="method"><code>fn <a href="#method.load" class="fnname">load</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#322-329" title="goto source code">[src]</a></h3><div class="docblock"><p>Loads the bits in the <code>self</code> region into a local value.</p>
<p>This can load into any of the unsigned integers which implement
<a href="../../bitvec/mem/trait.BitMemory.html"><code>BitMemory</code></a>. Any further transformation must be done by the user.</p>
<h1 id="target-specific-behavior-1" class="section-header"><a href="#target-specific-behavior-1">Target-Specific Behavior</a></h1>
<p><strong>THIS FUNCTION CHANGES BEHAVIOR FOR DIFFERENT TARGETS.</strong></p>
<p>The default implementation of this function calls <a href="../../bitvec/field/trait.BitField.html#tymethod.load_le"><code>load_le</code></a> on
little-endian byte-ordered CPUs, and <a href="../../bitvec/field/trait.BitField.html#tymethod.load_be"><code>load_be</code></a> on big-endian
byte-ordered CPUs.</p>
<p>If you are using this function from a region that crosses multiple
elements in memory, be aware that it will behave differently on
big-endian and little-endian target architectures.</p>
<h1 id="parameters-4" class="section-header"><a href="#parameters-4">Parameters</a></h1>
<ul>
<li><code>&amp;self</code>: A read reference to some bits in memory. This slice must be
trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the type
being loaded. This can be accomplished with range indexing on a larger
slice.</li>
</ul>
<h1 id="returns-2" class="section-header"><a href="#returns-2">Returns</a></h1>
<p>A value <code>M</code> whose least <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> significant bits are filled with
the bits of <code>self</code>.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
</div><h3 id="method.store" class="method"><code>fn <a href="#method.store" class="fnname">store</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#372-379" title="goto source code">[src]</a></h3><div class="docblock"><p>Stores a sequence of bits from the user into the domain of <code>self</code>.</p>
<p>This can store any of the unsigned integers which implement
<a href="../../bitvec/mem/trait.BitMemory.html"><code>BitMemory</code></a>. Any other types must first be transformed by the user.</p>
<h1 id="target-specific-behavior-2" class="section-header"><a href="#target-specific-behavior-2">Target-Specific Behavior</a></h1>
<p><strong>THIS FUNCTION CHANGES BEHAVIOR FOR DIFFERENT TARGETS.</strong></p>
<p>The default implementation of this function calls <a href="../../bitvec/field/trait.BitField.html#tymethod.store_le"><code>store_le</code></a> on
little-endian byte-ordered CPUs, and <a href="../../bitvec/field/trait.BitField.html#tymethod.store_be"><code>store_be</code></a> on big-endian
byte-ordered CPUs.</p>
<p>If you are using this function to store into a region that crosses
multiple elements in memory, be aware that it will behave differently on
big-endian and little-endian target architectures.</p>
<h1 id="parameters-5" class="section-header"><a href="#parameters-5">Parameters</a></h1>
<ul>
<li><code>&amp;mut self</code>: A write reference to some bits in memory. This slice must
be trimmed to have a width no more than the <a href="../../bitvec/mem/trait.BitMemory.html#associatedconstant.BITS"><code>M::BITS</code></a> width of the
type being stored. This can be accomplished with range indexing on a
larger slice.</li>
<li><code>value</code>: A value, whose <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits will be
stored into <code>self</code>.</li>
</ul>
<h1 id="behavior-2" class="section-header"><a href="#behavior-2">Behavior</a></h1>
<p>The <a href="../../bitvec/slice/struct.BitSlice.html#method.len"><code>self.len()</code></a> least significant bits of <code>value</code> are written into
the domain of <code>self</code>.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>This method is encouraged to panic if <code>self</code> is empty, or wider than a
single element <code>M</code>.</p>
</div></div><span class="loading-content">Loading content...</span><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"><h3 id="impl-BitField" class="impl"><code class="in-band">impl&lt;O, V&gt; BitField for <a class="struct" href="../../bitvec/array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;O, V&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../../bitvec/order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../../bitvec/view/trait.BitView.html" title="trait bitvec::view::BitView">BitView</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, V::<a class="type" href="../../bitvec/view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>&gt;: <a class="trait" href="../../bitvec/field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></code><a href="#impl-BitField" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#1346-1371" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le" class="method hidden"><code>fn <a href="#method.load_le" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1352-1355" title="goto source code">[src]</a></h4><h4 id="method.load_be" class="method hidden"><code>fn <a href="#method.load_be" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1357-1360" title="goto source code">[src]</a></h4><h4 id="method.store_le" class="method hidden"><code>fn <a href="#method.store_le" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1362-1365" title="goto source code">[src]</a></h4><h4 id="method.store_be" class="method hidden"><code>fn <a href="#method.store_be" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1367-1370" title="goto source code">[src]</a></h4></div><h3 id="impl-BitField-1" class="impl"><code class="in-band">impl&lt;T&gt; BitField for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;<a class="struct" href="../../bitvec/order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-BitField-1" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#717-1029" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le-1" class="method"><code>fn <a href="#method.load_le-1" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#765-821" title="goto source code">[src]</a></h4><div class="docblock"><p>Loads from <code>self</code>, using little-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element contains the least significant segment of the
returned value, in the bits at the most significant edge of the
element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice contains successively more-significant segments,
and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element contains the most significant segment of the
returned value, in the bits at the least significant edge of the
element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then the referent element is merely
loaded, shifted, and masked; no recombination of segments is necessary.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">store_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(
  <span class="number">0b1_1011_0100_1100_011</span>
<span class="comment">//  K LMNO PQRS TUVW XYZ</span>
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b011_00000</span>, <span class="number">0b0100_1100</span>, <span class="number">0b000_1_1011</span>
<span class="comment">//  XYZ          PQRS TUVW        K LMNO</span>
]);
<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b1_1011_0100_1100_011</span>,
<span class="comment">//  K LMNO PQRS TUVW XYZ</span>
);</pre></div>
</div><h4 id="method.load_be-1" class="method"><code>fn <a href="#method.load_be-1" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#868-905" title="goto source code">[src]</a></h4><div class="docblock"><p>Loads from <code>self</code>, using big-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element contains the most significant segment of the
returned value, in the bits at the most significant edge of the
element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice contains successively less-significant segments,
and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element contains the least significant segment of the
returned value, in the bits at the least significant edge of the
element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then the referent element is merely
loaded, shifted, and masked; no recombination of segments is necessary.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">store_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(
  <span class="number">0b011_1100_0100_1011_1</span>,
<span class="comment">//  KLM NOPQ RSTU VWXY Z</span>
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b011_00000</span>, <span class="number">0b1100_0100</span>, <span class="number">0b000_1011_1</span>
<span class="comment">//  KLM          NOPQ RSTU        VWXY Z</span>
]);
<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b011_1100_0100_1011_1</span>,
<span class="comment">//  KLM NOPQ RSTU VWXY Z</span>
);</pre></div>
</div><h4 id="method.store_le-1" class="method"><code>fn <a href="#method.store_le-1" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#932-964" title="goto source code">[src]</a></h4><div class="docblock"><p>Stores into <code>self</code>, using little-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element receives the least significant segment of
<code>value</code>, in the bits at the most significant edge of the element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice receives successively more-significant segments of
<code>value</code>, and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element receives the most significant segment of <code>value</code>,
in the bits at the least significant edge of the element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then <code>value</code> is shifted into place and
written without any segmentation.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>See the documentation for <code>&lt;BitSlice&lt;Lsb0, u8&gt; as BitField&gt;::load_le</code>.</p>
</div><h4 id="method.store_be-1" class="method"><code>fn <a href="#method.store_be-1" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#991-1028" title="goto source code">[src]</a></h4><div class="docblock"><p>Stores into <code>self</code>, using big-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element receives the most significant segment of <code>value</code>,
in the bits at the most significant edge of the element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice receives successively less-significant segments of
<code>value</code>, and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element receives the least significant segment of
<code>value</code>, in the bits at the least significant edge of the element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then <code>value</code> is shifted into place and
written without any segmentation.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>See the documentation for <code>&lt;BitSlice&lt;Lsb0, u8&gt; as BitField&gt;::load_be</code>.</p>
</div></div><h3 id="impl-BitField-2" class="impl"><code class="in-band">impl&lt;T&gt; BitField for <a class="struct" href="../../bitvec/slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;<a class="struct" href="../../bitvec/order/struct.Msb0.html" title="struct bitvec::order::Msb0">Msb0</a>, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../../bitvec/store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code><a href="#impl-BitField-2" class="anchor"></a><a class="srclink" href="../../src/bitvec/field.rs.html#1031-1344" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.load_le-2" class="method"><code>fn <a href="#method.load_le-2" class="fnname">load_le</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1079-1121" title="goto source code">[src]</a></h4><div class="docblock"><p>Loads from <code>self</code>, using little-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element contains the least significant segment of the
returned value, in the bits at the least significant edge of the
element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice contains successively more-significant segments,
and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element contains the most significant segment of the
returned value, in the bits at the most significant edge of the
element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then the referent element is merely
loaded, shifted, and masked; no recombination of segments is necessary.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">store_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(
  <span class="number">0b1_1011_0100_1100_110</span>
<span class="comment">//  K LMNO PQRS TUVW XYZ</span>
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b00000_110</span>, <span class="number">0b0100_1100</span>, <span class="number">0b1_1011_000</span>
<span class="comment">//        XYZ    PQRS TUVW    K LMNO</span>
]);
<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">load_le</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b1_1011_0100_1100_110</span>,
<span class="comment">//  K LMNO PQRS TUVW XYZ</span>
);</pre></div>
</div><h4 id="method.load_be-2" class="method"><code>fn <a href="#method.load_be-2" class="fnname">load_be</a>&lt;M&gt;(&amp;self) -&gt; M <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1168-1210" title="goto source code">[src]</a></h4><div class="docblock"><p>Loads from <code>self</code>, using big-endian element ordering if <code>self</code> spans
more than one element <code>T</code>.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element contains the most significant segment of the
returned value, in the bits at the least significant edge of the
element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice contains successively less-significant segments,
and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element contains the least significant segment of the
returned value, in the bits at the most significant edge of the
element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then the referent element is merely
loaded, shifted, and masked; no recombination of segments is necessary.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bitvec</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">store_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>(
  <span class="number">0b110_1011_1100_0100_1</span>
<span class="comment">//  KLM NOPQ RSTU VWXY Z</span>
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">data</span>, [
  <span class="number">0b00000_110</span>, <span class="number">0b1011_1100</span>, <span class="number">0b0100_1_000</span>
<span class="comment">//        KLM    NOPQ RSTU    VWXY Z</span>
]);
<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">5</span> .. <span class="number">21</span>].<span class="ident">load_be</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">val</span>,
  <span class="number">0b110_1011_1100_0100_1</span>,
<span class="comment">//  KLM NOPQ RSTU VWXY Z</span>
);</pre></div>
</div><h4 id="method.store_le-2" class="method"><code>fn <a href="#method.store_le-2" class="fnname">store_le</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1237-1277" title="goto source code">[src]</a></h4><div class="docblock"><p>Stores into <code>self</code>, using little-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element receives the least significant segment of
<code>value</code>, in the bits at the least significant edge of the element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice receives successively more-significant segments of
<code>value</code>, and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element receives the most significant segment of <code>value</code>,
in the bits at the most significant edge of the element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then <code>value</code> is shifted into place and
written without any segmentation.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>See the documentation for <code>&lt;BitSlice&lt;Msb0, u8&gt; as BitField&gt;::load_le</code>.</p>
</div><h4 id="method.store_be-2" class="method"><code>fn <a href="#method.store_be-2" class="fnname">store_be</a>&lt;M&gt;(&amp;mut self, value: M) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../../bitvec/mem/trait.BitMemory.html" title="trait bitvec::mem::BitMemory">BitMemory</a>,&nbsp;</span></code><a class="srclink" href="../../src/bitvec/field.rs.html#1304-1343" title="goto source code">[src]</a></h4><div class="docblock"><p>Stores into <code>self</code>, using big-endian element ordering if <code>self</code> spans
more than one <code>T</code> element.</p>
<p>If <a href="../../bitvec/slice/struct.BitSlice.html#method.domain"><code>self.domain()</code></a> produces a <a href="../../bitvec/domain/enum.Domain.html#variant.Region"><code>Domain::Region</code></a>, then:</p>
<ul>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.head"><code>head</code></a> element receives the most significant segment of <code>value</code>,
in the bits at the least significant edge of the element,</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.body"><code>body</code></a> slice receives successively less-significant segments of
<code>value</code>, and</li>
<li>its <a href="../../bitvec/domain/enum.Domain.html#variant.Region.field.tail"><code>tail</code></a> element receives the least significant segment of
<code>value</code>, in the bits at the most significant edge of the element.</li>
</ul>
<p>If the domain is an <a href="../../bitvec/domain/enum.Domain.html#variant.Enclave"><code>Enclave</code></a>, then <code>value</code> is shifted into place and
written without any segmentation.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>See the documentation for <code>&lt;BitSlice&lt;Lsb0, u8&gt; as BitField&gt;::load_be</code>.</p>
</div></div></div><span class="loading-content">Loading content...</span><script type="text/javascript" src="../../implementors/bitvec/field/trait.BitField.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec"></div>
    <script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>