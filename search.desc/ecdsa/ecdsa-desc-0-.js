searchState.loadedDescShard("ecdsa", 0, "Elliptic Curve Digital Signature Algorithm (ECDSA) as …\nMarker trait for elliptic curves in short Weierstrass form.\nSEC1 encoded curve point.\nContains the error value\nSignature errors.\nNormalize a scalar (i.e. ECDSA S) to the lower half the …\nContains the success value\nResult type.\nECDSA signature (fixed-size). Generic over elliptic curve …\nFixed-size byte array containing an ECDSA signature\nSize of a fixed sized signature for the given elliptic …\nECDSA signing key. Generic over elliptic curves.\nECDSA verification key (i.e. public key). Generic over …\nGet byte slice containing the serialized <code>EncodedPoint</code>.\nCompress this <code>EncodedPoint</code>, returning a new <code>EncodedPoint</code>.\nGet the <code>Coordinates</code> for this <code>EncodedPoint</code>.\nDecode this <code>EncodedPoint</code> into the desired type\nDecompress this <code>EncodedPoint</code>, returning a new <code>EncodedPoint</code>.\nSupport for ECDSA signatures encoded as ASN.1 DER.\nEncode an <code>EncodedPoint</code> from the desired type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncode an elliptic curve point from big endian serialized …\nInitialize signing key from a raw scalar serialized as a …\nDecode elliptic curve point (compressed or uncompressed) …\nParse a signature from ASN.1 DER\nInitialize <code>VerifyingKey</code> from an <code>EncodedPoint</code>.\nCreate a <code>Signature</code> from the serialized <code>r</code> and <code>s</code> scalar …\nInitialize <code>VerifyingKey</code> from a SEC1-encoded public key.\nCompute <code>EncodedPoint</code> representing the public key for the …\nDecode elliptic curve point from raw uncompressed …\nLow-level ECDSA primitives.\nReturn <code>EncodedPoint</code> representing the additive identity …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this <code>EncodedPoint</code> compact?\nIs this <code>EncodedPoint</code> compressed?\nIs this <code>EncodedPoint</code> the additive identity? (a.k.a. point …\nGet the length of the encoded point in bytes\nCreate a new error with no associated source\nNormalize scalar to the lower half of the field (i.e. …\nNormalize signature into “low S” form as described in …\nGet the <code>r</code> component of this signature\nGenerate a cryptographically random <code>SigningKey</code>.\nSupport for computing deterministic ECDSA ephemeral scalar …\nGet the <code>s</code> component of this signature\nGet the SEC1 tag for this <code>EncodedPoint</code>\nSerialize this <code>SigningKey</code> as bytes\nSerialize this signature as ASN.1 DER\nSerialize this <code>VerifyingKey</code> as a SEC1 <code>EncodedPoint</code>, …\nSerialize point as raw uncompressed coordinates without …\nSign message prehash using a deterministic ephemeral …\nSign message prehash using an ephemeral scalar (<code>k</code>) derived …\nGet the <code>VerifyingKey</code> which corresponds to this <code>SigningKey</code>\nGet the x-coordinate for this <code>EncodedPoint</code>.\nGet the y-coordinate for this <code>EncodedPoint</code>.\nMaximum overhead of an ASN.1 DER-encoded ECDSA signature …\nMaximum size of an ASN.1 DER encoded signature for the …\nASN.1 DER-encoded signature.\nBorrow this signature as a byte slice\nReturns the argument unchanged.\nParse an ASN.1 DER-encoded ECDSA signature from a byte …\nCalls <code>U::from(self)</code>.\nGet the length of the signature in bytes\nPreferred digest to use when computing ECDSA signatures …\nBind a preferred <code>Digest</code> algorithm to an elliptic curve …\nInstantiate this type from the output of a digest.\n<code>SignPrimitive</code> for signature implementations that can …\nTry to sign the given prehashed message using ECDSA.\nVerify the given prehashed message using ECDSA.\nInstantiate this type from a <code>Digest</code> instance\nTry to sign the prehashed message.\nTry to sign the prehashed message.\nVerify the prehashed message against the provided signature\nGenerate ephemeral scalar <code>k</code> from the secret scalar and a …")