searchState.loadedDescShard("crypto_bigint", 0, "Pure Rust implementation of a big integer library designed …\nCompute <code>self + rhs mod p</code>.\nSupport for encoding a big integer as a <code>GenericArray</code>.\nSize of this integer in bits.\nSize of this integer in bytes.\nAlias for a byte array whose size is defined by …\nSize of a byte array which encodes a big integer.\nProvides intentionally-checked arithmetic on <code>T</code>.\nConcatenate two numbers into a “wide” twice-width …\nEncoding support.\nNumber of bytes in a <code>Limb</code>.\nMaximum value this <code>UInt</code> can express.\nCompute <code>self * rhs mod p</code>.\nCompute <code>-self mod p</code>.\nThe value <code>1</code>.\nOutput type.\nOutput type.\nOutput type.\nOutput type.\nConcatenated output: twice the width of <code>Self</code>.\nSplit output: high/low components of the value.\nByte array representation.\nSplit a number in half, returning the most significant …\nCompute <code>self - rhs mod p</code>.\n1024-bit unsigned big integer\n128-bit unsigned big integer\n1536-bit unsigned big integer\n1792-bit unsigned big integer\n192-bit unsigned big integer\n2048-bit unsigned big integer\n256-bit unsigned big integer\n3072-bit unsigned big integer\n3584-bit unsigned big integer\n384-bit unsigned big integer\n4096-bit unsigned big integer\n448-bit unsigned big integer\n512-bit unsigned big integer\n6144-bit unsigned big integer\n64-bit unsigned big integer\n768-bit unsigned big integer\n8192-bit unsigned big integer\n896-bit unsigned big integer\nBig unsigned integer.\nProvides intentionally-wrapped arithmetic on <code>T</code>.\nThe value <code>0</code>.\nComputes <code>a + b + carry</code>, returning the result along with …\nCompute <code>self + rhs mod p</code>.\nComputes <code>self + rhs mod p</code> in constant time.\nPerform checked addition, returning a <code>CtOption</code> which …\nPerform checked multiplication, returning a <code>CtOption</code> which …\nPerform checked subtraction, returning a <code>CtOption</code> which …\nConcate the two values, with <code>self</code> as most significant and …\nType aliases for many constants.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize from a big-endian byte array.\nDecode from big endian bytes.\nCreate a new <code>UInt</code> from the provided big endian hex string.\nCreate a new <code>UInt</code> from the provided big endian bytes.\nDeserialize from a little-endian byte array.\nDecode from little endian bytes.\nCreate a new <code>UInt</code> from the provided little endian hex …\nCreate a new <code>UInt</code> from the provided little endian bytes.\nCreate a <code>UInt</code> from a <code>u128</code> (const-friendly)\nCreate a <code>UInt</code> from a <code>u16</code> (const-friendly)\nCreate a <code>UInt</code> from a <code>u32</code> (const-friendly)\nCreate a <code>UInt</code> from a <code>u64</code> (const-friendly)\nCreate a <code>UInt</code> from a <code>u8</code> (const-friendly)\nCreate a <code>UInt</code> from an array of the <code>limb::Inner</code> unsigned …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this <code>UInt</code> into its inner limbs.\nIs this <code>UInt</code> an odd number?\nDetermine if this <code>UInt</code> is equal to zero.\nBig integers are represented as an array of smaller CPU …\nBorrow the limbs of this <code>UInt</code>.\nCompute <code>self * rhs mod p</code>.\nCompute “wide” multiplication, with a product twice …\nCompute <code>-self mod p</code>.\nComputes <code>-a mod p</code> in constant time.\nCreate a new checked arithmetic wrapper for the given …\nConst-friendly <code>UInt</code> constructor.\nCalculate the number of limbs required to represent the …\nGenerate a cryptographically secure random <code>UInt</code>.\nGenerate a cryptographically secure random <code>UInt</code> which is …\nComputes <code>a - (b + borrow)</code>, returning the result along with …\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nNOTE: this operation is variable time with respect to <code>rhs</code> …\nComputes <code>self &gt;&gt; n</code>.\nSplit this number in half, returning its high and low …\nSquare self, returning a “wide” result.\nCompute <code>self - rhs mod p</code>.\nComputes <code>self - rhs mod p</code> in constant time.\nSerialize to a big-endian byte array.\nEncode to big endian bytes.\nSerialize to a little-endian byte array.\nEncode to little endian bytes.\nCreate an array of <code>limb::Inner</code> unsigned integer type from …\nPerform wrapping addition, discarding overflow.\nPerform wrapping multiplication, discarding overflow.\nPerform wrapping subtraction, discarding underflow and …\nThe type-level bit 0.\nThe type-level bit 1.\nThe type-level signed integer 0.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing the integer 0.\nSize of the inner integer in bits.\nSize of the inner integer in bytes.\nInner integer type that the <code>Limb</code> newtype wraps.\nBig integers are represented as an array of smaller CPU …\nMaximum value this <code>Limb</code> can express.\nThe value <code>1</code>.\nWide integer type: double the width of <code>Inner</code>.\nThe value <code>0</code>.\nComputes <code>self + rhs + carry</code>, returning the result along …\nCalculates <code>a &amp; b</code>.\nCalculates <code>a | b</code>.\nPerform checked addition, returning a <code>CtOption</code> which …\nPerform checked multiplication, returning a <code>CtOption</code> which …\nPerform checked subtraction, returning a <code>CtOption</code> which …\nPerform a comparison of the inner value in variable-time.\nPerforms an equality check in variable-time.\nReturns the argument unchanged.\nCreate a <code>Limb</code> from a <code>u16</code> integer (const-friendly)\nCreate a <code>Limb</code> from a <code>u32</code> integer (const-friendly)\nCreate a <code>Limb</code> from a <code>u64</code> integer (const-friendly)\nCreate a <code>Limb</code> from a <code>u8</code> integer (const-friendly)\nCalls <code>U::from(self)</code>.\nIs this limb an odd number?\nIs this limb equal to zero?\nComputes <code>self + (b * c) + carry</code>, returning the result …\nGenerate a random limb\nComputes <code>self - (rhs + borrow)</code>, returning the result along …\nPerform wrapping addition, discarding overflow.\nPerform wrapping multiplication, discarding overflow.\nPerform wrapping subtraction, discarding underflow and …")