searchState.loadedDescShard("elliptic_curve", 0, "General purpose Elliptic Curve Cryptography (ECC) support, …\nElliptic curve with affine arithmetic implementation.\nAffine point type for a given curve with a …\nElliptic curve point in affine coordinates.\nElliptic curve.\nContains the error value\nElliptic curve errors.\nThis trait represents an element of a field.\nByte representation of a base/scalar field element of a …\nSize of field elements of this elliptic curve.\nThis trait represents an element of a cryptographic group.\nNon-zero scalar type.\nOrder constant.\nContains the success value\nElliptic curve with projective arithmetic implementation.\nProjective point type for a given curve with a …\nElliptic curve point in projective coordinates.\nElliptic curve public keys.\nResult type.\nScalar field element for a particular elliptic curve.\nScalars modulo the order of this group’s scalar field.\nScalar field type.\nScalar arithmetic.\nScalar bytes: wrapper for <code>FieldBytes</code> which guarantees that …\nElliptic curve secret keys.\nInteger type used to represent field elements of this …\nBorrow the inner <code>AffinePoint</code> from this <code>PublicKey</code>.\nBorrow the inner <code>FieldBytes</code>\nBorrow the inner secret <code>ScalarBytes</code> value.\nType aliases for many constants.\nCubes this element.\nDoubles this element.\nDoubles this element.\nElliptic Curve Diffie-Hellman Support.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert an <code>AffinePoint</code> into a <code>PublicKey</code>\nDeserialize raw private scalar as a big endian integer\nInitialize <code>PublicKey</code> from an <code>EncodedPoint</code>\nDecode a <code>NonZeroScalar</code> from a serialized field element\nConvert from a <code>Scalar</code> type for this curve.\nDecode <code>PublicKey</code> (compressed or uncompressed) from the …\nCompute a <code>PublicKey</code> from a secret <code>NonZeroScalar</code> value …\nCreate <code>ScalarBytes</code> from the provided <code>C::UInt</code>.\nReturns a fixed generator of the prime-order subgroup.\nReturns the additive identity, also known as the “…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into <code>FieldBytes</code>\nConvert into a <code>Scalar</code> type for this curve.\nComputes the multiplicative inverse of this element, …\nPerform a scalar inversion\nDetermines if this point is the identity.\nReturns true iff this element is zero.\nIs this <code>ScalarBytes</code> value all zeroes?\nCreate new <code>ScalarBytes</code>, checking that the given input is …\nCreate a <code>NonZeroScalar</code> from a scalar.\nCreate a new secret key from a serialized scalar value\nReturns the one element of the field, the multiplicative …\nTraits for arithmetic operations on elliptic curve field …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nGet the <code>PublicKey</code> which corresponds to this secret key\nReturns an element chosen uniformly at random using a …\nReturns an element chosen uniformly at random from the …\nGenerate a random <code>NonZeroScalar</code>\nGenerate a random <code>SecretKey</code>\nSEC1 encoding support.\nReturns the square root of the field element, if it is …\nSquares this element.\nExpose the byte serialization of the value this <code>SecretKey</code> …\nSerialize this <code>PublicKey</code> as a SEC1 <code>EncodedPoint</code>, …\nConvert this <code>PublicKey</code> to a <code>ProjectivePoint</code> for the given …\nConvert to a <code>Scalar</code> type for this curve.\nGet the secret scalar value for this key..\nElliptic curves in short Weierstrass form.\nReturns the zero element of the field, the additive …\nCreate <code>ScalarBytes</code> representing a value of zero.\nThe type-level bit 0.\nThe type-level bit 1.\nThe type-level signed integer 0.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing this bit.\nInstantiates a singleton representing the integer 0.\nEphemeral Diffie-Hellman Secret.\nShared secret value computed via ECDH key agreement.\nShared secret value, serialized as bytes.\nLow-level Elliptic Curve Diffie-Hellman (ECDH) function.\nCompute a Diffie-Hellman shared secret from an ephemeral …\nReturns the argument unchanged.\nReturns the argument unchanged.\nNOTE: this impl is intended to be used by curve …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the public key associated with this ephemeral secret.\nGenerate a cryptographically random <code>EphemeralSecret</code>.\nThe addition operator <code>+</code>.\nThe addition assignment operator <code>+=</code>.\nPerform an inversion on a field element (i.e. base field …\nThe multiplication operator <code>*</code>.\nThe unary negation operator <code>-</code>.\nField element type\nThe resulting type after applying the <code>+</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>-</code> operator.\nThe resulting type after applying the <code>*</code> operator.\nThe subtraction operator <code>-</code>.\nThe subtraction assignment operator <code>-=</code>.\nPerforms the <code>+</code> operation.\nPerforms the <code>+=</code> operation.\nInvert a field element.\nPerforms the <code>*</code> operation.\nPerforms the unary <code>-</code> operation.\nPerforms the <code>-</code> operation.\nPerforms the <code>-=</code> operation.\nCompact curve point\nCompact point (<code>0x05</code>)\nCompressed curve point\nCompressed point with even y-coordinate (<code>0x02</code>)\nCompressed point with odd y-coordinate (<code>0x03</code>)\nSize of a compressed point for the given elliptic curve …\nEnum representing the coordinates of either compressed or …\nSEC1 encoded curve point.\nTrait for deserializing a value from a SEC1 encoded curve …\nIdentity point (a.k.a. point at infinity)\nIdentity point (<code>0x00</code>)\nTag byte used by the <code>Elliptic-Curve-Point-to-Octet-String</code> …\nTrait for serializing a value to a SEC1 encoded curve …\nTrait for serializing a value to a SEC1 encoded curve …\nUncompressed curve point\nUncompressed point (<code>0x04</code>)\nSize of an uncompressed point for the given elliptic curve …\nSize of an untagged point for given elliptic curve.\nValidate that the given <code>EncodedPoint</code> represents the …\nGet byte slice containing the serialized <code>EncodedPoint</code>.\nCompress this <code>EncodedPoint</code>, returning a new <code>EncodedPoint</code>.\nGet the <code>Coordinates</code> for this <code>EncodedPoint</code>.\nDecode this <code>EncodedPoint</code> into the desired type\nDecompress this <code>EncodedPoint</code>, returning a new <code>EncodedPoint</code>.\nEncode an <code>EncodedPoint</code> from the desired type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEncode an elliptic curve point from big endian serialized …\nDecode elliptic curve point (compressed or uncompressed) …\nDeserialize the type this trait is impl’d on from an …\nCompute <code>EncodedPoint</code> representing the public key for the …\nParse a tag value from a byte\nDecode elliptic curve point from raw uncompressed …\nReturn <code>EncodedPoint</code> representing the additive identity …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this <code>EncodedPoint</code> compact?\nIs this point compact?\nIs this <code>EncodedPoint</code> compressed?\nIs this point compressed?\nIs this <code>EncodedPoint</code> the additive identity? (a.k.a. point …\nIs this point the identity point?\nGet the length of the encoded point in bytes\nCompute the expected total message length for a message …\nGet the SEC1 tag for this <code>EncodedPoint</code>\nGet the tag octet needed to encode this set of <code>Coordinates</code>\nSerialize this value as a SEC1 <code>EncodedPoint</code>, optionally …\nSerialize this value as a SEC1 <code>EncodedPoint</code>, optionally …\nSerialize point as raw uncompressed coordinates without …\nValidate that the given <code>EncodedPoint</code> is a valid public key …\nGet the x-coordinate for this <code>EncodedPoint</code>.\nGet the y-coordinate for this <code>EncodedPoint</code>.\nx-coordinate\nx-coordinate\nx-coordinate\ny-coordinate\nIs the y-coordinate odd?\nShould point compaction be applied by default?\nShould point compression be applied by default?\nMarker trait for elliptic curves in short Weierstrass form.\nAttempt to decompact an elliptic curve point from an …\nAttempt to decompress an elliptic curve point from its …\nPoint compaction settings\nPoint compression settings.\nAttempt to decompact an elliptic curve point\nAttempt to decompress an elliptic curve point.")